---
title: "–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç 003: –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —á–µ—Ä–¥–∞—á–Ω—ã—Ö —Å—Ñ–µ—Ä —Å–∏–º–ø–ª–µ–∫—Å–∞"
tags: [algebra, geometry]
---

([–ü—Ä–æ–µ–∫—Ç —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞ –¥–æ—Å—Ç—É–ø–µ–Ω –∑–¥–µ—Å—å.](https://github.com/lounres/MEDia/tree/master/experiments/003))

11-16 –∏—é–ª—è 2025 –≥–æ–¥–∞ —Å–æ—Å—Ç–æ—è–ª–∞—Å—å V –∫–æ–Ω—Ñ–µ—Ä–µ–Ω—Ü–∏—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–µ–Ω—Ç—Ä–æ–≤ –†–æ—Å—Å–∏–∏.
–ù–∞ –Ω–µ–π –±—ã–ª–æ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏–µ –ù–∞—Ç–∞–ª—å–∏ –î–∞—É—Ä—Ü–µ–≤–æ–π, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –±—ã–ª–∞ —Ä–∞—Å—Å–∫–∞–∑–∞–Ω–∞ –∑–∞–¥–∞—á–∞ –æ —á–µ—Ä–¥–∞—á–Ω—ã—Ö —Å—Ñ–µ—Ä–∞—Ö.
–ó–∞–¥–∞—á–∞ —Å–æ—Å—Ç–æ–∏—Ç –≤ —Ç–æ–º, —á—Ç–æ–±—ã —Å–∫–∞–∑–∞—Ç—å, —Å–∫–æ–ª—å–∫–æ –≤–ø–∏—Å–∞–Ω–Ω—ã—Ö –≤ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ñ–∞—Å–µ—Ç –∫–∞–∫–æ–≥–æ-–ª–∏–±–æ —Å–∏–º–ø–ª–µ–∫—Å–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å.
–í —ç—Ç–æ–º —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–µ –º—ã –ø–æ–ø—Ä–æ–±—É–µ–º –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.

## –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–æ–µ –≤–≤–µ–¥–µ–Ω–∏–µ

–ü—É—Å—Ç—å –¥–ª—è $n > 2$ –¥–∞–Ω –∫–∞–∫–æ–π-—Ç–æ $(n-1)$-–º–µ—Ä–Ω—ã–π —Å–∏–º–ø–ª–µ–∫—Å $\Delta$ –≤ –ï–≤–∫–ª–∏–¥–æ–≤–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ.
(–§–æ—Ä–º–∞–ª—å–Ω–æ $\Delta$ &mdash; –≤—ã–ø—É–∫–ª–∞—è –æ–±–æ–ª–æ—á–∫–∞ $n$ –∞—Ñ—Ñ–∏–Ω–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö —Ç–æ—á–µ–∫.)
–£ –Ω–µ–≥–æ –µ—Å—Ç—å —Ä–æ–≤–Ω–æ $n$ –≤–µ—Ä—à–∏–Ω –∏ —Ä–æ–≤–Ω–æ $n$ —Ñ–∞—Å–µ—Ç.
–ï—Å–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —ç—Ç–∏ —Ñ–∞—Å–µ—Ç—ã –¥–æ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–µ–π –≤ $n-1$-–º–µ—Ä–Ω–æ–º –ï–≤–∫–ª–∏–¥–æ–≤–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ, –≤ –∫–æ—Ç–æ—Ä–æ–µ –º—ã –≤–ª–æ–∂–∏–ª–∏ $\Delta$,
—Ç–æ –ø–æ–ª—É—á–∏—Ç—Å—è —Ä–∞–∑–±–∏–µ–Ω–∏–µ —ç—Ç–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –Ω–∞ —á–∞—Å—Ç–∏, –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –∫–æ–Ω–µ—á–Ω–∞—è —á–∞—Å—Ç—å –∫–æ—Ç–æ—Ä–æ–≥–æ &mdash; —Å–∞–º —Å–∏–º–ø–ª–µ–∫—Å $\Delta$.
–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑ —ç—Ç–∏—Ö —á–∞—Å—Ç–µ–π (–Ω–µ –≤—Å–µ) –∏–º–µ—é—Ç –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≥—Ä–∞–Ω–∏—Ü –≤—Å–µ $n$ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–µ–π.
–ë—É–¥–µ–º –Ω–∞–∑—ã–≤–∞—Ç—å –∏—Ö *"—á–µ—Ä–¥–∞–∫–∞–º–∏"*.

–ö–∞–∫ –º—ã –∑–Ω–∞–µ–º, –≤ –ª—é–±–æ–π —Å–∏–º–ø–ª–µ–∫—Å –º–æ–∂–Ω–æ –≤–ø–∏—Å–∞—Ç—å —Å—Ñ–µ—Ä—É.
–ü–æ—Ö–æ–∂–∏–º –æ–±—Ä–∞–∑–æ–º –≤ –µ–≥–æ —á–µ—Ä–¥–∞–∫–∏ –º–æ–∂–Ω–æ —Ç–∞–∫–∂–µ –≤–ø–∏—Å–∞—Ç—å —Å—Ñ–µ—Ä—ã. –ù–æ –Ω–µ –≤—Å–µ–≥–¥–∞.
–ù–∞–ø—Ä–∏–º–µ—Ä, –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–µ—Ç—Ä–∞—ç–¥—Ä –≤–ø–∏—Å—ã–≤–∞—é—Ç—Å—è —Ä–æ–≤–Ω–æ 5 —Å—Ñ–µ—Ä—ã:
–æ–¥–Ω–∞ –≤–Ω—É—Ç—Ä–∏ –∏ –µ—â—ë –ø–æ –æ–¥–Ω–æ–π –ø—Ä–æ—Ç–∏–≤ –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã, –∑–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π –≥—Ä–∞–Ω—å—é.
–ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —Ç–æ, —á—Ç–æ –≤ –æ–±—â–µ–º —Å–ª—É—á–∞–µ –≤ —Ç–µ—Ç—Ä–∞—ç–¥—Ä –º–æ–∂–Ω–æ –≤–ø–∏—Å–∞—Ç—å —É–∂–µ–Ω 8 —Å—Ñ–µ—Ä:
–µ—â—ë 4 –≤–ø–∏—Å—ã–≤–∞—é—Ç—Å—è –≤ —á–µ—Ä–¥–∞–∫–∏, –∫–∞—Å–∞—è—Å—å –¥–≤—É—Ö –≥—Ä–∞–Ω–µ–π –∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–π –¥–≤—É—Ö –¥—Ä—É–≥–∏—Ö –≥—Ä–∞–Ω–µ–π.
–ü–æ—ç—Ç–æ–º—É –º–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å: –∞ –∫–∞–∫–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –≤–ø–∏—Å–∞–Ω–Ω—ã—Ö –≤ —á–µ—Ä–¥–∞–∫–∏ —Å—Ñ–µ—Ä —Å–∏–º–ø–ª–µ–∫—Å–∞ –º–æ–≥—É—Ç –±—ã—Ç—å?
–î–ª—è $n = 3$ –æ—Ç–≤–µ—Ç –æ—á–µ–≤–∏–¥–µ–Ω: 4 (–≤—Å–µ–≥–¥–∞ –º–æ–∂–Ω–æ –≤–ø–∏—Å–∞—Ç—å 1 –æ–∫—Ä—É–∂–Ω–æ—Å—Ç—å –∏ –≤–Ω–µ–≤–ø–∏—Å–∞—Ç—å 3 –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏).
–î–ª—è $n = 4$ –æ—Ç–≤–µ—Ç –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –æ—Ç $5$ –¥–æ $8$.
–ê —á—Ç–æ –¥–∞–ª—å—à–µ?

–û–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è, –¥–ª—è —Ç–µ—Ç—Ä–∞—ç–¥—Ä–æ–≤ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è:
<blockquote>
    **–õ–µ–º–º–∞ 1.** –ü—É—Å—Ç—å –¥–∞–Ω—ã $\delta_1, \dots, \delta_n \in \{1; -1\}$.
    –û–±–æ–∑–Ω–∞—á–∏–º –∑–∞ $S_i$ &mdash; –æ–±—ä—ë–º —Ñ–∞—Å–µ—Ç—ã –ø—Ä–æ—Ç–∏–≤ $i$-–æ–π –≤–µ—Ä—à–∏–Ω—ã —Å–∏–º–ø–ª–µ–∫—Å–∞.
    –¢–æ–≥–¥–∞ —Å—Ñ–µ—Ä–∞ –∫–∞—Å–∞—é—â–∞—è—Å—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –≥—Ä–∞–Ω–µ–π —Å–∏–º–ø–ª–µ–∫—Å–∞ —Ç–∞–∫,
    —á—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ $i \in \{1; \dots; n\}$ –µ—Å–ª–∏ –æ–Ω–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å —Ç–æ–π –∂–µ —Å—Ç–æ—Ä–æ–Ω—ã, —á—Ç–æ –∏ $\Delta$, —Ç–æ $\delta_i = 1$, –∏–Ω–∞—á–µ $\delta_i = -1$,
    –µ—Å—Ç—å —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $\sum_{i=1}^n S_i \delta_i > 0$.
</blockquote>
<blockquote>
    **–õ–µ–º–º–∞ 2.** –°–∏–º–ø–ª–µ–∫—Å —Å –æ–±—ä—ë–º–∞–º–∏ —Ñ–∞—Å–µ—Ç $S_i$ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $2 S_i < \sum_{k=1}^n S_k$ –¥–ª—è –≤—Å–µ—Ö i.
    (–¢.–µ. –Ω–∞ –¥–∞–Ω–Ω–æ–º –Ω–∞–±–æ—Ä —á–∏—Å–µ–ª –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —Å—Ç—Ä–æ–≥–∏–µ "–æ–±–æ–±—â—ë–Ω–Ω—ã–µ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞".)
</blockquote>

–ü–µ—Ä–≤–æ–µ –¥–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ. –ü—É—Å—Ç—å $A_i$ &mdash; $i$-–∞—è –≤–µ—Ä—à–∏–Ω–∞ —Å–∏–º–ø–ª–µ–∫—Å–∞, –∞ $C$ &mdash; –∫–∞–∫–∞—è-—Ç–æ —Ç–æ—á–∫–∞.
–¢–æ–≥–¥–∞ $V(A_1A_2\dots A_n) = \sum_{i=1}^n V(A_1\dots A_{i-1}CA_{i+1}\dots A_n)$ –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ –æ–±—ä—ë–º–æ–≤.
–≠—Ç–æ –ø–æ–Ω—è—Ç–Ω–æ –∏–∑ —Ç–æ–≥–æ, —á—Ç–æ –ø—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ —è–≤–ª—è–µ—Ç—Å—è –ª–∏–Ω–µ–π–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π –æ—Ç $C$,
–∫–æ—Ç–æ—Ä–∞—è —Ä–∞–≤–Ω–∞ –ª–µ–≤–æ–π –∫–æ–Ω—Å—Ç–∞–Ω—Ç–µ –≤–æ –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω–∞—Ö —Å–∏–º–ø–ª–µ–∫—Å–∞,
–∞ –∑–Ω–∞—á–∏—Ç –∏ –≤–æ –≤—Å—ë–º –∞—Ñ—Ñ–∏–Ω–Ω–æ–º –∑–∞–º—ã–∫–∞–Ω–∏–∏ —Å–∏–º–ø–ª–µ–∫—Å–∞.
–í–æ–∑—å–º—ë–º –≤ –∫–∞—á–µ—Å—Ç–≤–µ $C$ —Ü–µ–Ω—Ç—Ä –∏—Å–∫–æ–º–æ–π —Å—Ñ–µ—Ä—ã (–µ—Å–ª–∏ —Ç–∞–∫–æ–≤–∞—è –∏–º–µ–µ—Ç—Å—è).
–ü—É—Å—Ç—å —Ç–∞–∫–∂–µ $r$ &mdash; —Ä–∞–¥–∏—É—Å —ç—Ç–æ–π —Å—Ñ–µ—Ä—ã.
–¢–æ–≥–¥–∞ $V(A_1\dots A_{i-1}CA_{i+1}\dots A_n) = r S(A_1\dots A_{i-1}A_{i+1}\dots A_n) / n$.
–û—Ç–∫—É–¥–∞ –∏–º–µ–µ–º
$$
V(A_1A_2\dots A_n) = \frac{r}{n} \sum_{i=1}^n S(A_1\dots A_{i-1}A_{i+1}\dots A_n)
$$
$$
\frac{n V(A_1A_2\dots A_n)}{\sum_{i=1}^n S(A_1\dots A_{i-1}A_{i+1}\dots A_n)} = r
$$
–¢.–µ. —Ä–∞–¥–∏—É—Å —Å—Ñ–µ—Ä—ã –æ–ø—Ä–µ–¥–µ–ª—ë–Ω —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ $\sum_{i=1}^n S(A_1\dots A_{i-1}A_{i+1}\dots A_n) > 0$.
–ü—Ä–∏ —ç—Ç–æ–º $S(A_1\dots A_{i-1}A_{i+1}\dots A_n) = S_i \delta_i$, –æ—Ç–∫—É–¥–∞ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –∏—Å–∫–æ–º–æ–µ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ.
–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–Ω—è—Ç—å –≤–µ—Ä–Ω–æ—Å—Ç—å –≤ –æ–±—Ä–∞—Ç–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É.
–ù–æ —Ç—É—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –æ–±—Ä–∞—Ç–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É:
—É—Ä–∞–≤–Ω–µ–Ω–∏—è –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–µ–π $(n-1)$-–æ–π –∏–∑ –≥—Ä–∞–Ω–µ–π –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã
(—Ç–∞–∫ –∫–∞–∫ –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è —Ä–æ–≤–Ω–æ –≤ 1 —Ç–æ—á–∫–µ).
–ó–Ω–∞—á–∏—Ç –µ—Å–ª–∏ –∏—Ö —Å–¥–≤–∏–Ω—É—Ç—å –Ω–∞ $r := \frac{n V}{\sum_{i=1}^n S_i \delta_i}$ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã,
—Ç–æ –ø–æ–ª—É—á–∏–º —Ü–µ–Ω—Ç—Ä —Å—Ñ–µ—Ä—ã —Å —Ä–∞–¥–∏—É—Å–æ–º $r$, –∫–∞—Å–∞—é—â—É—é—Å—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —ç—Ç–∏—Ö $n-1$ –≥—Ä–∞–Ω–µ–π —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å—Ç–æ—Ä–æ–Ω.
–¢–æ–≥–¥–∞ –ø–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤—É –Ω–∞ –æ–±—ä—ë–º—ã –ø–æ–ª—É—á–∏–º, —á—Ç–æ –æ–Ω–∞ –∫–∞—Å–∞–µ—Ç—Å—è –µ—â—ë –∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–π $n$-–æ–π –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã.

–í—Ç–æ—Ä–æ–π —Ñ–∞–∫—Ç –∞–≤—Ç–æ—Ä—ã –¥–æ–∫–∞–∑—ã–≤–∞—Ç—å –Ω–µ —É–º–µ—é—Ç –∏ —Å—Å—ã–ª–∫—É –¥–∞—Ç—å —Ç–æ–∂–µ –Ω–µ –º–æ–≥—É—Ç. –ò–∑–≤–∏–Ω–∏—Ç–µ.

–û—Ç—Å—é–¥–∞ –∑–∞–¥–∞—á–∞ —Å–≤–æ–¥–∏—Ç—Å—è –∫ —á–∏—Å—Ç–æ –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–æ–π:
<blockquote>
    –î–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–∞–±–æ—Ä–∞ $(S_1, \dots, S_n)$ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª
    —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤ –≤–∏–¥–∞ $\sum_{i=1}^n \delta_i S_i > 0$,
    –≥–¥–µ $\delta_i \in \{1; -1\}$, –∫–æ—Ç–æ—Ä–æ–µ –¥–ª—è –Ω–µ–≥–æ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è.
    –ù–∞–π–¥–∏—Ç–µ –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–æ–ª—É—á–∞–µ–º—ã–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞.
</blockquote>
–ù–æ –¥–∞–≤–∞–π—Ç–µ –ø–æ–π–¥—ë–º —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã. –ó–∞–º–µ—Ç–∏–º, —á—Ç–æ –≤—Å–µ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –±—å—é—Ç—Å—è –Ω–∞ –ø–∞—Ä—ã "–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö":
–¥–ª—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ $(\delta_i)_{i=1}^n$ –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã $(-\delta_i)_{i=1}^n$.
–ï—Å–ª–∏ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ $\sum_{i=1}^n \delta_i S_i = 0$, —Ç–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ —Ä–æ–≤–Ω–æ –æ–¥–Ω–æ –∏–∑ —ç—Ç–∏—Ö –¥–≤—É—Ö –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤.
–ï—Å–ª–∏ –∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ &mdash; —Ç–æ –Ω–∏–∫–∞–∫–æ–µ.
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –º–æ–∂–Ω–æ –∑–∞–¥–∞—Ç—å –≤–æ–ø—Ä–æ—Å, –∞ —Å–∫–æ–ª—å–∫–æ —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤–∏–¥–∞ $\sum_{i=1}^n \delta_i S_i = 0$
(—Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ —Å–º–µ–Ω—ã –∑–Ω–∞–∫–∞ –≤—Å–µ—Ö —Å–ª–∞–≥–∞–µ–º—ã—Ö) —É –Ω–∞—Å –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è?
–í—ã—á—Ç—è —ç—Ç–æ —á–∏—Å–ª–æ –∏–∑ $2^{n-1}$ –º—ã –ø–æ–ª—É—á–∏–º –æ–¥–∏–Ω –∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤.

–¢.–µ. –∑–∞–¥–∞—á–∞ –æ–±—Ä–µ–ª–∞ —Å–ª–µ–¥—É—é—â–∏–π —Å–æ–≤—Å–µ–º –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–π –≤–∏–¥:
<blockquote>
    –í –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ $\mathbb{R}^n$ –≤ –æ–±–ª–∞—Å—Ç–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏ $0 < 2 x_i < \sum_{i=1}^n x_i$
    —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —É—Ä–∞–≤–Ω–µ–Ω–∏—è –≤–∏–¥–∞ $\sum_{i=1}^n \pm x_i = 0$ (–æ—Ç–æ–∂–¥–µ—Å—Ç–≤–ª—è—è —É—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–æ —Å–º–µ–Ω–æ–π –∑–Ω–∞–∫–æ–≤).
    –î–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ –æ–±–ª–∞—Å—Ç–∏ –ø–æ—Å–º–æ—Ç—Ä–∏–º –∫–∞–∫–æ–º—É —á–∏—Å–ª—É —É—Ä–∞–≤–Ω–µ–Ω–∏–π –æ–Ω–æ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç.
    –ö–∞–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å?
</blockquote>

## –ü–ª–∞–Ω –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏

–ù–µ—Å–ª–æ–∂–Ω–æ –∑–∞–º–µ—Ç–∏—Ç—å, —á—Ç–æ –≤—Å–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è –∏ —É—Å–ª–æ–≤–∏—è-–Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –æ–¥–Ω–æ—Ä–æ–¥–Ω—ã.
–ü–æ—ç—Ç–æ–º—É –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–∞–±–æ—Ä—ã, –≥–¥–µ $\sum_{i=1}^n x_i = 1$.
–í –¥–∞–Ω–Ω–æ–º –≥–∏–ø–µ—Ä–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –æ–±–ª–∞—Å—Ç—å –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å –∫–∞–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ (–∫–æ–Ω–µ—á–Ω–æ–≥–æ) –ø–æ–ª–∏—Ç–æ–ø–∞.
–¢–æ–≥–¥–∞ –ø–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π –±—É–¥–µ—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ —Å–ª–µ–¥—É—é—â–∏–π:
1. –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ–≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤–∏–¥–∞ $\sum_{i=1}^n \pm x_i = 0$,
   –≤–∑—è–≤ —Ç–æ–ª—å–∫–æ —Ç–µ, —á—Ç–æ –∏–º–µ—é—Ç —Ä–µ—à–µ–Ω–∏—è, –∏ –æ–±—ä–µ–¥–∏–Ω–∏–≤ –≤—Å–µ —Å–∏—Å—Ç–µ–º—ã —Å –æ–¥–Ω–∏–º –∏ —Ç–µ–º –∂–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º —Ä–µ—à–µ–Ω–∏–π.
2. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ–ª–∏—Ç–æ–ø, –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Å–∏—Å—Ç–µ–º–æ–π –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤ $0 < 2 x_i < \sum_{i=1}^n x_i$ –≤ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏ $\sum_{i=1}^n x_i = 1$.
3. –î–ª—è –∫–∞–∂–¥–æ–π —Å–∏—Å—Ç–µ–º—ã –∏–∑ –ø. 1 –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∞—Ñ—Ñ–∏–Ω–Ω–æ–µ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –µ—ë —Ä–µ—à–µ–Ω–∏–π –≤ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏ $\sum_{i=1}^n x_i = 1$
   –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –µ–≥–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –ø–æ–ª–∏—Ç–æ–ø–æ–º, –ø–æ—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º –≤ –ø. 2.
4. –í—ã—á–∏—Å–ª–∏—Ç—å –≤—Å–µ —Ä–∞–∑–º–µ—Ä—ã —Å–∏—Å—Ç–µ–º —É—Ä–∞–≤–Ω–µ–Ω–∏–π, –ø—Ä–æ—à–µ–¥—à–∏—Ö –ø—Ä–æ–≤–µ—Ä–∫—É –≤ –ø.2 –∏ –≤—ã–≤–µ—Å—Ç–∏ –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (–ø–æ –æ–¥–Ω–æ–º—É —Ä–∞–∑—É).

## üîµ –û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ: –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –Ω–∞–±–æ—Ä–∞ –≤–µ–∫—Ç–æ—Ä–æ–≤ –∫ –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–º—É –º–Ω–æ–∂–µ—Å—Ç–≤—É –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–≥–æ –≤–∏–¥–∞

–î–ª—è –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏–π –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É—é—Ç—Å—è –¥–≤–∞ –≤–∏–¥–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤ –õ–ù–ú.

### –ê–ª–≥–æ—Ä–∏—Ç–º –ì–∞—É—Å—Å–∞

–ü–µ—Ä–≤–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è &mdash; –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º—É —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º—É –≤–∏–¥—É.
–ù–æ —Å–Ω–∞—á–∞–ª–∞ –æ–ø—Ä–µ–¥–µ–ª–∏–º "–ø—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç—ã–π –≤–∏–¥":

<blockquote>
    **–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ.** –ì–æ–≤–æ—Ä—è—Ç, —á—Ç–æ –º–∞—Ç—Ä–∏—Ü–∞ –∏–∑ $m$ —Å—Ç—Ä–æ–∫ (–∏–ª–∏ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –∏–∑ $m$ –≤–µ–∫—Ç–æ—Ä–æ–≤)
    –∏–º–µ–µ—Ç –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç—ã–π –≤–∏–¥ –≤ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–º –±–∞–∑–∏—Å–µ,
    –µ—Å–ª–∏ –¥–ª—è –∫–∞–∂–¥–æ–π $i$-–æ–π —Å—Ç—Ä–æ–∫–∏ –º–∞—Ç—Ä–∏—Ü—ã (–∫–∞–∂–¥–æ–≥–æ $i$-–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –∏–∑ –Ω–∞–±–æ—Ä–∞) –µ—Å—Ç—å —á–∏—Å–ª–æ $k_i$, —á—Ç–æ
    $$
    1 \leqslant k_1 < k_2 < \dots < k_m \leqslant n
    $$
    –∞ —Ç–∞–∫–∂–µ:
    1. –≤—Å—è–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç $i$-–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–æ $k_i$-–æ–≥–æ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–≤–µ–Ω $0$,
    2. $k_i$-—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç $i$-–æ–π —Å—Ç—Ä–æ–∫–∏ —Ä–∞–≤–µ–Ω $1$,
    3. –¥–ª—è –≤—Å—è–∫–∏—Ö $1 \leqslant i < j \leqslant m$ $i$-–∞—è —Å—Ç—Ä–æ–∫–∞ –∏–º–µ–µ—Ç –Ω–æ–ª—å –Ω–∞ $k_j$-–æ–º –º–µ—Å—Ç–µ.

    –ò–Ω–∞—á–µ –≥–æ–≤–æ—Ä—è, –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å —Ç–∞–∫–∏–µ $k_i$,
    —á—Ç–æ –≤—ã–¥–µ–ª—è—è —Å—Ç–æ–ª–±—Ü—ã —Å –Ω–æ–º–µ—Ä–∞–º–∏ $k_i$ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –µ–¥–∏–Ω–∏—á–Ω–∞—è –∫–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞–∑–º–µ—Ä–∞ $m$.
</blockquote>

–î–ª—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –¥–∞–Ω–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –≤–µ–∫—Ç–æ—Ä–æ–≤ –∫ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º—É —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º—É –≤–∏–¥—É –µ—Å—Ç—å –≤—Å–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ì–∞—É—Å—Å–∞.

–ü—É—Å—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω –±–∞–∑–∏—Å $B$.
–®–∞–≥ –∞–ª–≥–æ—Ä–∏—Ç–º–∞, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞—Å—à–∏—Ä—è–µ—Ç –õ–ù–ú $U$ —Ä–∞–∑–º–µ—Ä–∞ $m$ –≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ –Ω–æ–≤—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º $v$, —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:
1. –ü—É—Å—Ç—å $\mathrm{firstNonZeroIndex}$ &mdash; –ø–µ—Ä–≤—ã–π –∏–Ω–¥–µ–∫—Å –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ $v$ –ø—Ä–∏ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–∏ –ø–æ $B$,
   $\mathrm{basisIndex} := 0$, $\mathrm{coefficientIndex} := 0$.
2. –ü–æ–∫–∞ $\mathrm{basisIndex} < m$ –±—É–¥–µ–º –¥–µ–ª–∞—Ç—å —Å–ª–µ–¥—É—é—â–µ–µ:
   1. –ï—Å–ª–∏ $\mathrm{firstNonZeroIndex} = n$, —Ç–æ –¥–æ–±–∞–≤–∏–º –≤ –Ω–æ–≤–æ–µ –õ–ù–ú –≤—Å–µ –≤–µ–∫—Ç–æ—Ä–∞ —Å—Ç–∞—Ä–æ–≥–æ
      —Å –Ω–æ–º–µ—Ä–∞ $\mathrm{basisIndex}$ –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ –ø–æ –Ω–æ–º–µ—Ä $m$ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ,
      –≤–µ—Ä–Ω—ë–º –Ω–æ–≤–æ–µ –õ–ù–ú –∏ –∑–∞–∫–æ–Ω—á–∏–º —Ä–∞–±–æ—Ç—É –∞–ª–≥–æ—Ä–∏—Ç–º–∞.
   2. –ï—Å–ª–∏ $\mathrm{basisIndex} = m$, —Ç–æ –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–¥–µ–ª–∏–º $v$ –Ω–∞ –µ–≥–æ –∂–µ –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç $v[\mathrm{firstNonZeroIndex}]$,
      –≤—ã—á—Ç–µ–º (–Ω–æ–≤—ã–π) $v$ –∏–∑ –≤—Å–µ—Ö –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ $u_i$ –≤ –Ω–æ–≤—ã–π –õ–ù–ú —Å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º $u_i[\mathrm{firstNonZeroIndex}]$,
      –¥–æ–±–∞–≤–∏–º –≤ –Ω–æ–≤–æ–µ –õ–ù–ú –ø–æ–ª—É—á–∏–≤—à–∏–π—Å—è $v$, –≤–µ—Ä–Ω—ë–º –Ω–æ–≤–æ–µ –õ–ù–ú –∏ –∑–∞–∫–æ–Ω—á–∏–º —Ä–∞–±–æ—Ç—É –∞–ª–≥–æ—Ä–∏—Ç–º–∞.
   3. –û–±–Ω–æ–≤–∏–º $\mathrm{coefficientIndex}$ –¥–æ –Ω–æ–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ $u_{\mathrm{basisIndex}}$.
   4. –ï—Å–ª–∏ $\mathrm{coefficientIndex} > \mathrm{firstNonZeroIndex}$,
      —Ç–æ –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–¥–µ–ª–∏–º $v$ –Ω–∞ –µ–≥–æ –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç ($v[\mathrm{firstNonZeroIndex}]$),
      –∫–∞–∂–¥—ã–π –≤–µ–∫—Ç–æ—Ä $u_i$ –¥–ª—è $i \in [\mathrm{basisIndex}; m)$ —Å –∏–Ω–¥–µ–∫—Å–æ–º $k_i$ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞
      –≤—ã—á—Ç–µ–º –∏–∑ $v$ —Å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º $v[k_i]$, –∑–∞—Ç–µ–º –≤—ã—á—Ç–µ–º $v$ –∏–∑ –∫–∞–∂–¥–æ–≥–æ $u_i$ –¥–ª—è $i \in [0; \mathrm{basisIndex})$,
      –ø–æ—Å–ª–µ —á–µ–≥–æ, –Ω–∞–∫–æ–Ω–µ—Ü, –¥–æ–±–∞–≤–∏–º $v$, –∞ –∑–∞ –Ω–∏–º –≤—Å–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è $u_i$.
   5. –ò–Ω–∞—á–µ –¥–æ–±–∞–≤–∏–º $u_{\mathrm{basisIndex}}$ –≤ –Ω–æ–≤–æ–µ –õ–ù–ú,
      –≤—ã—á—Ç–µ–º –µ–≥–æ –∏–∑ $v$ —Å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º $v[\mathrm{coefficientIndex}]$,
      –æ–±–Ω–æ–≤–∏–º $\mathrm{firstNonZeroIndex}$,
      –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä—É–µ–º $\mathrm{basisIndex}$ –∏ $\mathrm{coefficientIndex}$
      –∏ –ø—Ä–æ–¥–æ–ª–∂–∏–º —Ü–∏–∫–ª.

–ß—Ç–æ–±—ã –ø—Ä–∏–≤–µ—Å—Ç–∏ –≤—Å—ë –õ–ù–ú –∫ –¥–∞–Ω–Ω–æ–º—É –≤–∏–¥—É, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –≤ –Ω–æ–≤–æ–µ –õ–ù–ú –≤–µ–∫—Ç–æ—Ä–∞ —Å—Ç–∞—Ä–æ–≥–æ –ø–æ –æ—á–µ—Ä–µ–¥–∏ —Å –ø–æ–º–æ—â—å—é –¥–∞–Ω–Ω–æ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞.

–ü—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç—ã–π –≤–∏–¥ —Ç–∞–∫–∂–µ –æ–±–ª–∞–¥–∞–µ—Ç –æ—á–µ–Ω—å –≤–∞–∂–Ω—ã–º —Å–≤–æ–π—Å—Ç–≤–æ–º, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è:
<blockquote>
    **–õ–µ–º–º–∞ 3.** –ü—É—Å—Ç—å $V_1$ –∏ $V_2$ &mdash; –¥–≤–∞ –∫–æ–Ω–µ—á–Ω—ã—Ö –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤–µ–∫—Ç–æ—Ä–æ–≤ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –ª–∏–Ω–µ–π–Ω–æ–π –æ–±–æ–ª–æ—á–∫–æ–π.
    –¢–æ–≥–¥–∞ –¥–≤–∞ –õ–ù–ú, –ø–æ–ª—É—á–∞–µ–º—ã—Ö –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ì–∞—É—Å—Å–∞ –∫ $V_1$ –∏ $V_2$ —Å–æ–≤–ø–∞–¥–∞—é—Ç –∫–∞–∫ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –≤–µ–∫—Ç–æ—Ä–æ–≤.
</blockquote>

–≠—Ç–æ—Ç —Ñ–∞–∫—Ç –Ω–∞ –¥–µ–ª–µ –ø—Ä–æ—Å—Ç.
–°–Ω–∞—á–∞–ª–∞ –¥–æ–∫–∞–∂–µ–º —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–ª—è —Å–ª—É—á–∞—è, –∫–æ–≥–¥–∞ $V_1$ –∏ $V_2$ &mdash; –õ–ù–ú;
–æ–±—â–∏–π —Ñ–∞–∫—Ç —Ç–æ–≥–¥–∞ –±—É–¥–µ—Ç —Å–ª–µ–¥–æ–≤–∞—Ç—å –∏–∑ —Ç–æ–≥–æ, —á—Ç–æ –º—ã –≤—ã–±–µ—Ä–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –ª–∏–Ω–µ–π–Ω–æ–π –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ $U_1$ –∏ $U_2$ –º–Ω–æ–∂–µ—Å—Ç–≤ $V_1$ –∏ $V_2$,
—á—Ç–æ –Ω–µ—Ç –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤ —Å –º–µ–Ω—å—à–∏–º–∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤,
–æ—Ç—á–µ–≥–æ –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ –ª–∏–Ω–µ–π–Ω—ã—Ö –æ–±–æ–ª–æ—á–µ–∫ $\mathrm{span}(U_1) = \mathrm{span}(V_1) = \mathrm{span}(V_2) = \mathrm{span}(U_2)$,
–æ—Ç–∫—É–¥–∞ –±—É–¥–µ—Ç —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è $\mathrm{Gauss}(V_1) = \mathrm{Gauss}(U_1) = \mathrm{Gauss}(U_2) = \mathrm{Gauss}(V_2)$.

–¢–æ–≥–¥–∞ –∑–∞–º–µ—Ç–∏–º, —á—Ç–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ $V_i$ –∫ $\mathrm{Gauss}(V_i)$
—è–≤–ª—è–µ—Ç—Å—è –æ–±—ã—á–Ω—ã–º –¥–æ–º–Ω–æ–∂–µ–Ω–∏–µ–º –Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω—É—é –æ–±—Ä–∞—Ç–∏–º—É—é –º–∞—Ç—Ä–∏—Ü—É $G_i$ —Ä–∞–∑–º–µ—Ä–∞ $m$ —Å–ª–µ–≤–∞.
–ü—Ä–∏ —ç—Ç–æ–º —Å–∞–º–æ –ø–æ —Å–µ–±–µ $V_2$ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –∏–∑ $V_1$ –¥–æ–º–Ω–æ–∂–µ–Ω–∏–µ–º —Å–ª–µ–≤–∞ –Ω–∞ –∫–≤–∞–¥—Ä–∞—Ç–Ω—É—é –æ–±—Ä–∞—Ç–∏–º—É—é –º–∞—Ç—Ä–∏—Ü—É $H$ —Ä–∞–∑–º–µ—Ä–∞ $m$ —Å–ª–µ–≤–∞.
($H$ –ø–æ —Å—É—Ç–∏ –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Å–º–µ–Ω—É –±–∞–∑–∏—Å–∞ –≤ $\mathrm{span}(V_1) = \mathrm{span}(V_2)$.)
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º
$$
\mathrm{Gauss}(V_2) = G_2 V_2 = G_2 H V_1 = G_2 H G_1^{-1} \mathrm{Gauss}(V_1)
$$
–ü–æ–∫–∞–∂–µ–º, —á—Ç–æ $M := G_2 H G_1^{-1}$ —è–≤–ª—è–µ—Ç—Å—è –µ–¥–∏–Ω–∏—á–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ–π.
–î–ª—è —ç—Ç–æ–≥–æ –∑–∞–º–µ—Ç–∏–º, —á—Ç–æ —Å—Ç–æ–ª–±—Ü—ã "—Å—Ç—É–ø–µ–Ω–µ–∫" $\mathrm{Gauss}(V_1)$ &mdash;
—ç—Ç–æ –Ω–∞–±–æ—Ä –∏–∑ $m$ –ø–µ—Ä–≤—ã—Ö –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ –º–∞—Ç—Ä–∏—Ü–µ $\mathrm{Gauss}(V_1)$.
–ê –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –æ–Ω–∏ –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã –∏ –≤ $\mathrm{Gauss}(V_2)$, —Ç–∞–∫ –∫–∞–∫ $M$ –æ–±—Ä–∞—Ç–∏–º–∞.
–ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –Ω–∞–æ–±–æ—Ä–æ—Ç: –ø–µ—Ä–≤—ã–µ $m$ –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö —Å—Ç–æ–ª–±—Ü–æ–≤ –≤ $\mathrm{Gauss}(V_2)$ –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã –∏ –≤ $\mathrm{Gauss}(V_1)$.
–ó–Ω–∞—á–∏—Ç —Å—Ç–æ–ª–±—Ü—ã —Å—Ç—É–ø–µ–Ω–µ–∫ –≤ $\mathrm{Gauss}(V_1)$ –∏ –≤ $\mathrm{Gauss}(V_1)$ —Å–æ–≤–ø–∞–¥–∞—é—Ç
–∏ –æ–±—Ä–∞–∑—É—é—Ç –≤ –æ–±–µ–∏—Ö –º–∞—Ç—Ä–∏—Ü–∞—Ö –µ–¥–∏–Ω–∏—á–Ω—ã–µ –ø–æ–¥–º–∞—Ç—Ä–∏—Ü—ã.
–°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, $M$ —è–≤–ª—è–µ—Ç—Å—è –µ–¥–∏–Ω–∏—á–Ω–æ–π, –æ—Ç–∫—É–¥–∞ –∏ —Å–∞–º–∏ $\mathrm{Gauss}(V_i)$ —Ä–∞–≤–Ω—ã.

#### –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

–ù–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å –∏–º–µ—é—â–∏–µ—Å—è –õ–ù–ú –≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ –¥–æ –Ω–æ–≤—ã—Ö –õ–ù–ú.
–î–ª—è —ç—Ç–æ–≥–æ –∑–∞–≤–µ–¥—ë–º –ø—Ä–æ—Å—Ç–µ–Ω—å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
interface BasisExtender<Vector> {
    fun KoneList<Vector>.extend(newVector: Vector): KoneList<Vector>
}

context(basisExtender: BasisExtender<Vector>)
fun <Vector> KoneList<Vector>.extend(newVector: Vector): KoneList<Vector> =
    with(basisExtender) { this@extend.extend(newVector) }
```
–°–∞–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∞–±—Å—Ç—Ä–∞–≥–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –±–∞–∑–∏—Å–∞:
–æ–Ω –ø—Ä–æ—Å—Ç–æ –¥–∞—ë—Ç —Ñ–∞—Å–∞–¥, –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞, –Ω–µ —Å–º–æ—Ç—Ä—è –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é.
–§—É–Ω–∫—Ü–∏—è –ø–æ—Å–ª–µ –Ω–µ–≥–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ `extend` –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ `BasisExtender`,
–∫–æ–≥–¥–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ—Å—Ç—É–ø–µ–Ω –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞.

–°–∞–º–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
class GaussDiagonalBasisExtender<Number, Vector>(
    private val field: Field<Number>,
    private val vectorSpace: VectorSpace<Number, Vector>,
    private val dimension: UInt,
    private val basisDecomposition: VectorSpaceBasisDecomposition<Number, Vector, UInt>,
) : BasisExtender<Vector> {
    override fun KoneList<Vector>.extend(newVector: Vector): KoneList<Vector> = context(field, vectorSpace) {
        KoneList.build(this.size + 1u) {
            var newVector = newVector
            var firstNonZeroIndex = 0u
            while (firstNonZeroIndex < dimension && basisDecomposition.decompose(newVector)[firstNonZeroIndex].isZero()) firstNonZeroIndex++

            var basisIndex = 0u
            var coefficientIndex = 0u
            while (true) {
                if (firstNonZeroIndex == dimension) {
                    addSeveral(this@extend.size - basisIndex) { this@extend[it + basisIndex] }
                    break
                }
                if (basisIndex == this@extend.size) {
                    newVector /= basisDecomposition.decompose(newVector)[firstNonZeroIndex]
                    for (index in 0u ..< basisIndex) {
                        this[index] -= newVector * basisDecomposition.decompose(this[index])[firstNonZeroIndex]
                    }
                    add(newVector)
                    break
                }

                val basisVectorDecomposition = basisDecomposition.decompose(this@extend[basisIndex])
                while (basisVectorDecomposition[coefficientIndex].isZero()) coefficientIndex++

                if (coefficientIndex > firstNonZeroIndex) {
                    newVector /= basisDecomposition.decompose(newVector)[firstNonZeroIndex]
                    val basisSeparator = basisIndex
                    while (basisIndex < this@extend.size) {
                        val basisVectorDecomposition = basisDecomposition.decompose(this@extend[basisIndex])
                        while (basisVectorDecomposition[coefficientIndex].isZero()) coefficientIndex++
                        newVector -= this@extend[basisIndex] * basisDecomposition.decompose(newVector)[coefficientIndex]
                        basisIndex++
                        coefficientIndex++
                    }
                    for (index in 0u ..< basisSeparator) {
                        this[index] -= newVector * basisDecomposition.decompose(this[index])[firstNonZeroIndex]
                    }
                    add(newVector)
                    addSeveral(this@extend.size - basisSeparator) { this@extend[it + basisSeparator] }
                    break
                }

                val newVectorCoef = basisDecomposition.decompose(newVector)[coefficientIndex]
                add(this@extend[basisIndex])
                newVector -= this@extend[basisIndex] * newVectorCoef
                while (firstNonZeroIndex < dimension && basisDecomposition.decompose(newVector)[firstNonZeroIndex].isZero()) firstNonZeroIndex++
                basisIndex++
                coefficientIndex++
            }
        }
    }
}
```

–î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä—ë–º –ø–æ —á–∞—Å—Ç—è–º. –°–Ω–∞—á–∞–ª–∞ –∏–¥—ë—Ç ~–º–∏—à—É—Ä–∞~ —Ñ–æ—Ä–º–∞–ª—å–Ω–∞—è –æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
class GaussDiagonalBasisExtender<Number, Vector>(
    private val field: Field<Number>,
    private val vectorSpace: VectorSpace<Number, Vector>,
    private val dimension: UInt,
    private val basisDecomposition: VectorSpaceBasisDecomposition<Number, Vector, UInt>,
) : BasisExtender<Vector> {
    override fun KoneList<Vector>.extend(newVector: Vector): KoneList<Vector> = context(field, vectorSpace) {
        KoneList.build(this.size + 1u) {
            // ...
        }
    }
}
```
–¢—É—Ç –º—ã –Ω–∞–ø–∏—Å–∞–ª–∏, —á—Ç–æ –º—ã —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–∞–¥ —á–∏—Å–ª–∞–º–∏ —Ç–∏–ø–∞ `Number` –∏ –≤–µ–∫—Ç–æ—Ä–∞–º–∏ —Ç–∏–ø–∞ `Vector`,
–ø—Ä–∏–Ω–∏–º–∞—é—â–∏–π –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–µ—Ä–º–∞–Ω–µ–Ω—Ç–Ω—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤:
1. `field: Field<Number>` &mdash; –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ —á–∏—Å–ª–∞—Ö
   (–∑–Ω–∞—á–µ–Ω–∏–µ –Ω—É–ª—è –∏ –µ–¥–∏–Ω–∏—Ü—ã, –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å–ª–æ–∂–µ–Ω–∏—è, –≤—ã—á–∏—Ç–∞–Ω–∏—è –∏ —É–º–Ω–æ–∂–µ–Ω–∏—è –∏ —Ç.–¥.),
2. `vectorSpace: VectorSpace<Number, Vector>` &mdash; –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞—Ö –∏ —á–∏—Å–ª–∞—Ö
   (–∑–Ω–∞—á–µ–Ω–∏–µ –Ω—É–ª–µ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞, —Å–ª–æ–∂–µ–Ω–∏–µ –∏ –≤—ã—á–∏—Ç–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤, —É–º–Ω–æ–∂–µ–Ω–∏—è –Ω–∞ —Å–∫–∞–ª—è—Ä –∏ —Ç.–¥.),
3. `dimension: UInt` &mdash; —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–≥–æ –±–∞–∑–∏—Å–∞ `basisDecomposition`,
4. `basisDecomposition: VectorSpaceBasisDecomposition<Number, Vector, UInt>` &mdash; –æ–±—ä–µ–∫—Ç,
   –∫–æ—Ç–æ—Ä—ã–π –¥–ª—è –≤—Å—è–∫–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ `i` —Ç–∏–ø–∞ `UInt`
   (–Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –Ω–µ –ª—é–±–æ–≥–æ, –∞ –æ—Ç `0` –¥–æ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–≥–æ –≤ –±—É–¥—É—â–µ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ)
   –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ç–∏–ø–∞ `Number` –ø—Ä–∏ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–∏ –¥–∞–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Ç–∏–ø–∞ `Vector` –ø–æ –¥–∞–Ω–Ω–æ–º—É —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É –±–∞–∑–∏—Å—É
   (–≤ –±—É–¥—É—â–µ–º —ç—Ç–∏–º –±–∞–∑–∏—Å–æ–º –±—É–¥–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –±–∞–∑–∏—Å –∏–∑ –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤–∏–¥–∞ $(0, \dots, 0, 1, 0, \dots, 0)$).

–ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–æ, –∫–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –∞–ª–≥–æ—Ä–∏—Ç–º.
–í—ã–∑–æ–≤ `context(field, vectorSpace) { /* ... */ }` –ø—Ä–æ—Å—Ç–æ –¥–µ–ª–∞–µ—Ç `field` –∏ `vectorSpace` –¥–æ—Å—Ç—É–ø–Ω—ã–º–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
–í—ã–∑–æ–≤ `KoneList.build(this.size + 1u) { /* ... */ }` –≤–Ω—É—Ç—Ä–∏ –Ω–µ–≥–æ –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫-–õ–ù–ú.
–¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–π–¥—ë–º –∫ —Å–∞–º–æ–º—É –∞–ª–≥–æ—Ä–∏—Ç–º—É –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è.

–°–Ω–∞—á–∞–ª–∞ –∏–¥—É—Ç —Å—Ç—Ä–æ–∫–∏
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
var newVector = newVector
var firstNonZeroIndex = 0u
while (firstNonZeroIndex < dimension && basisDecomposition.decompose(newVector)[firstNonZeroIndex].isZero()) firstNonZeroIndex++
```
–∫–æ—Ç–æ—Ä—ã–µ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `newVector` –Ω–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –º—ã –±—É–¥–µ–º –º–µ–Ω—è—Ç—å –∏ –≤ –∫–æ–Ω—Ü–µ, –º–æ–∂–µ—Ç –±—ã—Ç—å, –¥–æ–±–∞–≤–∏–º,
–∏ –∏–∑–º–µ–Ω—è–µ–º—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `firstNonZeroIndex` –∏–Ω–¥–µ–∫—Å–∞ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –≤ `newVector`.
–î–∞–ª–µ–µ –º—ã –Ω–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ—Ö–æ–¥–∏—Ç—Å—è –ø–æ –≤–µ–∫—Ç–æ—Ä–∞–º –∏–º–µ—é—â–µ–≥–æ—Å—è –õ–ù–ú, –ø–µ—Ä–µ–±–∏—Ä–∞—è –∏—Ö –ø–æ–¥—Ä—è–¥:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
var basisIndex = 0u
var coefficientIndex = 0u
while (true) {
    /* ... */
}
```
–ù–∞ –Ω–∞—á–∞–ª–æ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Ü–∏–∫–ª–∞ `while` `basisIndex` —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –µ—â—ë –Ω–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –∏–∑ –Ω–∞—à–µ–≥–æ –õ–ù–ú,
`coefficientIndex` &mdash; –Ω–∞ –∏–Ω–¥–µ–∫—Å, –Ω–µ –±–æ–ª—å—à–∏–π –∏–Ω–¥–µ–∫—Å–∞ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ `basisIndex`-–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–º–µ—é—â–µ–≥–æ—Å—è –õ–ù–ú
(–µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç —Å –∏–Ω–¥–µ–∫—Å–æ–º `basisIndex` —Å—É—â–µ—Å—Ç–≤—É–µ—Ç; –∏–Ω–∞—á–µ `coefficientIndex` –Ω–µ –∏–º–µ–µ—Ç –æ—Å–º—ã—Å–ª–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è),
–∞ `firstNonZeroIndex` &mdash; –Ω–∞ –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ `newVector` (–∏–ª–∏ `dimension`, –µ—Å–ª–∏ `newVector` –Ω—É–ª–µ–≤–æ–π).
–¢–∞–∫–∂–µ –Ω–∞ –Ω–∞—á–∞–ª–æ –∏—Ç–µ—Ä–∞—Ü–∏–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç, —á—Ç–æ –º—ã –¥–æ–±–∞–≤–∏–ª–∏ —Ç–æ–ª—å–∫–æ –≤–µ–∫—Ç–æ—Ä—ã,
–ø–µ—Ä–≤—ã–µ –Ω–µ–Ω—É–ª–µ–≤—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –∫–æ—Ç–æ—Ä—ã—Ö –∏–¥—É—Ç —Å—Ç—Ä–æ–≥–æ –¥–æ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ `newVector`.

–í –Ω–∞—á–∞–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –º—ã –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–Ω–∞–ª—å–Ω—ã–µ –∫—Ä–∞–µ–≤—ã–µ —Å–ª—É—á–∞–∏:
1. –µ—Å–ª–∏ `coefficientIndex == dimension`, —Ç.–µ. `newVector` &mdash; –Ω—É–ª–µ–≤–æ–π –≤–µ–∫—Ç–æ—Ä,
2. –µ—Å–ª–∏ `basisIndex == this@extend.size`, —Ç.–µ. –º—ã –ø—Ä–æ—à–ª–∏—Å—å –ø–æ –≤—Å–µ–º –≤–µ–∫—Ç–æ—Ä–∞–º (–∏ –≤—ã—á–ª–∏ –∏—Ö –∏–∑ `newVector` —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏),
3. –µ—Å–ª–∏ (–ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è `coefficientIndex` –¥–æ –ø–µ—Ä–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ `basisIndex`-–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –≤ –õ–ù–ú)
   `coefficientIndex > firstNonZeroIndex`, —Ç.–µ. –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —É `newVector` –∏–¥—ë—Ç —Å—Ç—Ä–æ–≥–æ —Ä–∞–Ω—å—à–µ, —á–µ–º —É `basisIndex`-–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞.

–¢.–µ. –∫–æ–¥ –∏–º–µ–µ—Ç –≤–∏–¥
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
while (true) {
    if (firstNonZeroIndex == dimension) {
        /* ... */
    }
    if (basisIndex == this@extend.size) {
        /* ... */
    }

    val basisVectorDecomposition = basisDecomposition.decompose(this@extend[basisIndex])
    while (basisVectorDecomposition[coefficientIndex].isZero()) coefficientIndex++

    if (coefficientIndex > firstNonZeroIndex) {
        /* ... */
    }

    /* ... */
}
```

–í –ø–µ—Ä–≤–æ–º —Å–ª—É—á–∞–µ, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –≤–µ–∫—Ç–æ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –µ—â—ë –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –∏ –∑–∞–∫–æ–Ω—á–∏—Ç—å —Ä–∞–±–æ—Ç—É:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
if (firstNonZeroIndex == dimension) {
    addSeveral(this@extend.size - basisIndex) { this@extend[it + basisIndex] }
    break
}
```

–í–æ –≤—Ç–æ—Ä–æ–º —Å–ª—É—á–∞–µ –º—ã –ø–æ–ª—É—á–∞–µ–º –Ω–µ–Ω—É–ª–µ–≤–æ–π –≤–µ–∫—Ç–æ—Ä `newVector`.
–ü—Ä–∏ —ç—Ç–æ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫-–õ–ù–ú.
–ó–Ω–∞—á–∏—Ç, –µ—Å–ª–∏ –º—ã –¥–æ–±–∞–≤–∏–º `newVector` –≤ —ç—Ç–æ—Ç —Å–ø–∏—Å–æ–∫, —Ç–æ –º—ã –ø–æ–ª—É—á–∏–º –Ω–æ–≤–æ–µ –õ–ù–ú –≤ —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ.
–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω—ã–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç—ã–π –≤–∏–¥,
–Ω–∞–¥–æ –æ—Ç–Ω–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –≤–µ–∫—Ç–æ—Ä –ø–æ –µ–≥–æ –ø–µ—Ä–≤–æ–º—É –Ω–µ–Ω—É–ª–µ–≤–æ–º—É –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—É (—Å–¥–µ–ª–∞—Ç—å –µ–≥–æ –µ–¥–∏–Ω–∏—á–Ω—ã–º)4
–∏ –≤—ã—á–µ—Å—Ç—å –∏–∑ –≤—Å–µ—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
if (basisIndex == this@extend.size) {
    newVector /= basisDecomposition.decompose(newVector)[firstNonZeroIndex]
    for (index in 0u ..< basisIndex) {
        this[index] -= newVector * basisDecomposition.decompose(this[index])[firstNonZeroIndex]
    }
    add(newVector)
    break
}
```

–í —Ç—Ä–µ—Ç—å–µ–º —Å–ª—É—á–∞–µ, —É –Ω–∞—Å –¥–∞–Ω –Ω–µ–Ω—É–ª–µ–≤–æ–π `newVector`, `basisIndex` —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –∫–∞–∫–æ–π-—Ç–æ –≤–µ–∫—Ç–æ—Ä,
–Ω–æ –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∏–Ω–¥–µ–∫—Å `basisIndex`-–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –∏–¥—ë—Ç —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –Ω–µ–Ω—É–ª–µ–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ `newVector`.
–ó–Ω–∞—á–∏—Ç, –µ—Å–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å —Å–Ω–∞—á–∞–ª–∞ `newVector`, –∞ –ø–æ—Ç–æ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å—Ç–∞—Ä–æ–≥–æ –õ–ù–ú, —Ç–æ –ø–æ–ª—É—á–∏–º –õ–ù–ú –≤ —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ.
–î–ª—è –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–≥–æ —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–≥–æ –≤–∏–¥–∞ –Ω—É–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ –≤—ã—á–µ—Å—Ç—å –≤—Å–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä–∞ –∏–∑ `newVector` —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏,
–∞ –ø–æ—Ç–æ–º –≤—ã—á–µ—Å—Ç—å `newVector` —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏ –∏–∑ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤:
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
if (coefficientIndex > firstNonZeroIndex) {
    newVector /= basisDecomposition.decompose(newVector)[firstNonZeroIndex]
    val basisSeparator = basisIndex
    while (basisIndex < this@extend.size) {
        val basisVectorDecomposition = basisDecomposition.decompose(this@extend[basisIndex])
        while (basisVectorDecomposition[coefficientIndex].isZero()) coefficientIndex++
        newVector -= this@extend[basisIndex] * basisDecomposition.decompose(newVector)[coefficientIndex]
        basisIndex++
        coefficientIndex++
    }
    for (index in 0u ..< basisSeparator) {
        this[index] -= newVector * basisDecomposition.decompose(this[index])[firstNonZeroIndex]
    }
    add(newVector)
    addSeveral(this@extend.size - basisSeparator) { this@extend[it + basisSeparator] }
    break
}
```

–ù–∞–∫–æ–Ω–µ—Ü, –µ—Å–ª–∏ –∏ —Ç—Ä–µ—Ç–∏–π –∫—Ä–∞–µ–≤–æ–π —Å–ª—É—á–∞–π –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è, —Ç–æ –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç `newVector` –∏–¥—ë—Ç –Ω–µ —Ä–∞–Ω—å—à–µ, —á–µ–º –≤ `basisIndex`-–æ–º –≤–µ–∫—Ç–æ—Ä–µ.
–ó–Ω–∞—á–∏—Ç, –≤—Ç–æ—Ä–æ–π –Ω—É–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –≤—ã—á–µ—Å—Ç—å –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º, —á—Ç–æ–±—ã –ø–µ—Ä–≤—ã–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —à—ë–ª —Å—Ç—Ä–æ–≥–æ –ø–æ—Å–ª–µ,
–∞ –∑–∞—Ç–µ–º –¥–æ–±–∞–≤–∏—Ç—å `basisIndex`-—ã–π –≤–µ–∫—Ç–æ—Ä –≤ –Ω–∞—à –õ–ù–ú, –æ–±–Ω–æ–≤–ª—è—è `basisIndex`, `firstNonZeroIndex` (–∏ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π `coefficientIndex`):
```kotlin title="GaussReducedRowEchelonFormBasisExtender.kt"
val newVectorCoef = basisDecomposition.decompose(newVector)[coefficientIndex]
add(this@extend[basisIndex])
newVector -= this@extend[basisIndex] * newVectorCoef
while (firstNonZeroIndex < dimension && basisDecomposition.decompose(newVector)[firstNonZeroIndex].isZero()) firstNonZeroIndex++
basisIndex++
coefficientIndex++
```

### –ê–ª–≥–æ—Ä–∏—Ç–º –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞

–í—Ç–æ—Ä–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è &mdash; –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω–æ–º—É –≤–∏–¥—É,
—Å–æ—Ö—Ä–∞–Ω—è—è –ª–∏–Ω–µ–π–Ω—ã–µ –æ–±–æ–ª–æ—á–∫–∏ –ø–µ—Ä–≤—ã—Ö $k$ –≤–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ $k$.

–ö–æ–Ω–∫—Ä–µ—Ç–Ω–æ, –∞–ª–≥–æ—Ä–∏—Ç–º –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞ –∑–∞–º–µ–Ω—è–µ—Ç –Ω–∞–±–æ—Ä –≤–µ–∫—Ç–æ—Ä–æ–≤ $(v_i)_{i=1}^m$ –Ω–∞ –Ω–∞–±–æ—Ä –≤–µ–∫—Ç–æ—Ä–æ–≤ $(u_i)_{i=1}^m$,
—á—Ç–æ $\mathrm{span}(v_1, \dots, v_i) = \mathrm{span}(u_1, \dots, u_i)$, –∞ –ª—é–±—ã–µ –¥–≤–∞ –≤–µ–∫—Ç–æ—Ä–∞ $u_i$ –¥—Ä—É–≥ –¥—Ä—É–≥—É –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã
(–≤ —Ç–æ–º —Å–º—ã—Å–ª–µ, —á—Ç–æ –Ω—É–ª–µ–≤–æ–π –≤–µ–∫—Ç–æ—Ä –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–µ–Ω –ª—é–±–æ–º—É –¥—Ä—É–≥–æ–º—É).
–û–ø–∏—à–µ–º —Å–∞–º –∞–ª–≥–æ—Ä–∏—Ç–º.

–®–∞–≥ –∞–ª–≥–æ—Ä–∏—Ç–º–∞, –∫–æ—Ç–æ—Ä—ã–π –¥–æ–±–∞–≤–ª—è–µ—Ç –≤ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä –≤–µ–∫—Ç–æ—Ä–æ–≤ $U$ —Ä–∞–∑–º–µ—Ä–∞ $m$
(—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —É—Å–ª–æ–≤–∏—è, —á—Ç–æ $\mathrm{span}(u_1, \dots, u_i) = \mathrm{span}(v_1, \dots, v_i)$)
–Ω–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä $v_{m+1}$, —Ä–∞–±–æ—Ç–∞–µ—Ç —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:
1. –î–ª—è –∫–∞–∂–¥–æ–≥–æ $i \in (1; \dots; m)$, —á—Ç–æ $u_i \neq \overline{0}$ –ø—Ä–æ—Å—Ç–æ –∑–∞–º–µ–Ω–∏–º $v_{m+1}$ –Ω–∞
   $$
   v_{m+1} := v_{m+1} - u_i \frac{\langle v_{m+1}, u_i \rangle}{\langle u_i, u_i \rangle}
   $$

–¢.–µ. —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –º—ã –∑–∞–º–µ–Ω—è–µ–º $v_{m+1}$ –Ω–∞
$$
u_{m+1} := v_{m+1} - \sum_{\substack{i=1..m\\ u_i \neq \overline{0}}} u_i \frac{\langle v_{m+1}, u_i \rangle}{\langle u_i, u_i \rangle}
$$
(–¢–∞–∫ –∫–∞–∫ –≤—Å–µ $u_i$ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã, —Ç–æ –Ω–µ –≤–∞–∂–Ω–æ, –±—É–¥–µ–º –ª–∏ –º—ã –≤—ã—á–∏—Å–ª—è—Ç—å –≤—ã—á–∏—Ç–∞–µ–º—ã–µ —Å–ª–∞–≥–∞–µ–º—ã–µ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏ –≤—ã—á–∏—Ç–∞—Ç—å –∏—Ö –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ, –∫–∞–∫ –≤ —Ñ–æ—Ä–º—É–ª–µ,
–∏–ª–∏ –±—É–¥–µ–º –≤—ã—á–∏—Å–ª—è—Ç—å –≤—ã—á–∏—Ç–∞—Ç—å –∏—Ö –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, –∫–∞–∫ –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–µ.)

–ß—Ç–æ–±—ã –ø—Ä–∏–≤–µ—Å—Ç–∏ –≤—Å—ë –∫–æ–Ω–µ—á–Ω–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–π –≤–∏–¥,
–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤ –ø—É—Å—Ç–æ–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –¥–æ–±–∞–≤–ª—è—Ç—å —ç—Ç–∏ –≤–µ–∫—Ç–æ—Ä–∞ —Å –ø–æ–º–æ—â—å—é –æ–ø–∏—Å–∞–Ω–Ω–æ–≥–æ —à–∞–≥–∞.
–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –õ–ù–ú, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ—Ç–±—Ä–æ—Å–∏—Ç—å –ø–æ–ª—É—á–∞–µ–º—ã–µ –Ω—É–ª–µ–≤—ã–µ –≤–µ–∫—Ç–æ—Ä–∞.

#### –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

–ù–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –±–∞–∑–∏—Å —Ü–µ–ª–∏–∫–æ–º –∏ –±—Ä–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç.
(–¢.–µ. –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å –≤–µ–∫—Ç–æ—Ä, –Ω–∞—Ö–æ–¥—è—â–∏–π—Å—è –≤ –¥–∞–Ω–Ω–æ–º –≤–µ–∫—Ç–æ—Ä–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ, –Ω–æ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª—å–Ω—ã–π –¥–∞–Ω–Ω–æ–º—É –µ–≥–æ –≥–∏–ø–µ—Ä–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤—É.)

–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –±—É–¥–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å —Ç–∞–∫:
```kotlin title="orthogonalizeByGramSchmidt.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, *>)
fun <Number, Vector> KoneList<Vector>.orthogonalizeByGramSchmidt(): KoneList<Vector> =
    KoneList.build {
        val basis = this@orthogonalizeByGramSchmidt
        for (index in 0u ..< basis.size)
            +(0u ..< index).fold(basis[index]) { accumulator, subindex ->
                val subVector = this[subindex]
                accumulator - subVector * ((accumulator dot subVector) / (subVector dot subVector))
            }
    }
```

–î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä—ë–º –ø–æ —á–∞—Å—Ç—è–º. –°–Ω–∞—á–∞–ª–∞ –∏–¥—ë—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:
```kotlin title="orthogonalizeByGramSchmidt.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, *>)
fun <Number, Vector> KoneList<Vector>.orthogonalizeByGramSchmidt(): KoneList<Vector> =
```
–¢—É—Ç –æ–ø–∏—Å–∞–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è `orthogonalizeByGramSchmidt`
—Å —Ç–∏–ø–æ–≤—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ `Number` –∏ `Vector` –¥–ª—è —á–∏—Å–µ–ª –∏ –≤–µ–∫—Ç–æ—Ä–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º—ã –±—É–¥–µ–º —Ä–∞–±–æ—Ç–∞—Ç—å
–∏ —Å–ª–µ–¥—É—é—â–∏–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏:
1. –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç `_: Field<Number>` &mdash; –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ —á–∏—Å–ª–∞—Ö –≤ –ø–æ–ª–µ.
2. –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç `_: EuclideanSpaceOverField<Number, Vector, *>` &mdash;
   –æ–±—ä–µ–∫—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–µ–∞–ª–∏–∑—É–µ—Ç –±–∞–∑–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞ –≤–µ–∫—Ç–æ—Ä–∞—Ö –∏ —á–∏—Å–ª–∞—Ö –≤ –µ–≤–∫–ª–∏–¥–æ–≤–æ–º –≤–µ–∫—Ç–æ—Ä–Ω–æ–º –ø–æ–ª–µ.
3. –†–µ—Å–∏–≤–µ—Ä `KoneList<Vector>.` &mdash; –¥–∞–Ω–Ω—ã–π –±–∞–∑–∏—Å –¥–ª—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏.

–ü–æ—Å–ª–µ `=` –≤ –∫–æ–Ω—Ü–µ —ç—Ç–æ–≥–æ —Å–Ω–∏–ø–ø–µ—Ç–∞ –∏–¥—ë—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ —Ç–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏.
–ê –∏–º–µ–Ω–Ω–æ –¥–∞–ª—å—à–µ –∏–¥—ë—Ç –ø—Ä–æ—Å—Ç–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ —Å—Ç—Ä–æ–∏—Ç –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é –≤ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö:
```kotlin title="orthogonalizeByGramSchmidt.kt"
KoneList.build {
    /* ... */
}
```

–ü–µ—Ä–≤–æ–µ, —á—Ç–æ –º—ã –¥–µ–ª–∞–µ–º –≤ —ç—Ç–∏—Ö —Å–∫–æ–±–∫–∞—Ö &mdash;
–ø—Ä–æ—Å—Ç–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ —Ä–µ—Å–∏–≤–µ—Ä–∞ `this@orthogonalizeByGramSchmidt` –Ω–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `basis`:
```kotlin title="orthogonalizeByGramSchmidt.kt"
val basis = this@orthogonalizeByGramSchmidt
```

–î–∞–ª—å—à–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω —Ü–∏–∫–ª `for`, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–æ—Ö–æ–¥–∏—Ç—å—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π `index` –ø–æ –≤—Å–µ–º –∏–Ω–¥–µ–∫—Å–∞–º –±–∞–∑–∏—Å–∞ `basis`
–∏ –≤–Ω–æ—Å–∏—Ç `index`-—ã–π —ç–ª–µ–º–µ–Ω—Ç `basis`-–∞ –≤ –Ω–∞—à –∫–æ–Ω—Å—Ç—Ä—É–∏—Ä—É–µ–º—ã–π —Å–ø–∏—Å–æ–∫ –∑–∞—Ä–∞–Ω–µ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤—ã–≤–∞—è –µ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞:
```kotlin title="orthogonalizeByGramSchmidt.kt"
for (index in 0u ..< basis.size)
    /* ... */
```

–†–∞–∑–±–µ—Ä—ë–º—Å—è —Å —Ç–µ–º, –∫–∞–∫ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ì—Ä–∞–º–∞-–®–º–∏–¥—Ç–∞.
–í–∑—è–≤ –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –±–∞–∑–∏—Å–∞ `basis[index]`, –Ω–∞–º –Ω–∞–¥–æ –≤—ã—á–µ—Å—Ç—å –∏–∑ –Ω–µ–≥–æ –µ–≥–æ "–∫–æ–º–ø–æ–Ω–µ–Ω—Ç—É"
–ø–æ –∫–∞–∂–¥–æ–º—É –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É–∂–µ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –±–∞–∑–∏—Å–∞.
–ï—Å–ª–∏ –Ω—ã–Ω–µ—à–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—à–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –ø–æ—Å–ª–µ –≤—ã—á–∏—Ç–∞–Ω–∏—è –ø–µ—Ä–≤—ã—Ö `subindex` –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –µ—Å—Ç—å `accumulator`,
–∞ —Å–ª–µ–¥—É—é—â–∏–π –≤—ã—á–∏—Ç–∞–µ–º—ã–π –≤–µ–∫—Ç–æ—Ä &mdash; `subVector`,
—Ç–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ `accumulator` –ø–æ —ç—Ç–æ–º—É –±–∞–∑–∏—Å–Ω–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É –±—É–¥–µ—Ç —Ä–∞–≤–Ω–∞
```kotlin title="orthogonalizeByGramSchmidt.kt"
subVector * ((accumulator dot subVector) / (subVector dot subVector))
```
–≥–¥–µ `u dot v` &mdash; —Å–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ `u` –∏ `v`.
–¢–æ–≥–¥–∞ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—à–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ
```kotlin title="orthogonalizeByGramSchmidt.kt"
accumulator - subVector * ((accumulator dot subVector) / (subVector dot subVector))
```
–ß—Ç–æ–±—ã –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é `fold`,
–∏—Ç–µ—Ä–∏—Ä—É—é—â–∏–º—Å—è –ø–æ –≤—Å–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–º –∏–Ω–¥–µ–∫—Å–∞–º (—Ç.–µ. `subindex` –∏–∑ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ `0u ..< index`).
–ü—Ä–∏ —ç—Ç–æ–º –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–∞—ë–º `basis[index]`:
```kotlin title="orthogonalizeByGramSchmidt.kt"
(0u ..< index).fold(basis[index]) { accumulator, subindex ->
    val subVector = this[subindex]
    accumulator - subVector * ((accumulator dot subVector) / (subVector dot subVector))
}
```
–¢—É—Ç `this` —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –∫–æ–Ω—Å—Ç—Ä—É–∏—Ä—É–µ–º—ã–π —Å–ø–∏—Å–æ–∫.
–û—Ç—á–µ–≥–æ `val subVector = this[subindex]` —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ `subindex`-—ã–π —É–∂–µ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.
–ü–æ—ç—Ç–æ–º—É –≤ –±–ª–æ–∫–µ –ø—Ä–∏ `fold` –º—ã —Å–Ω–∞—á–∞–ª–∞ –ø–æ–º–µ—â–∞–µ–º —ç—Ç–æ—Ç –≤–µ–∫—Ç–æ—Ä –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `subVector`,
–∞ –ø–æ—Ç–æ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –¥–ª—è –ø–æ–¥–º–µ–Ω—ã –∏–º–µ—é—â–µ–≥–æ—Å—è –∑–Ω–∞—á–µ–Ω–∏—è `accumalator`.
–ü–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏ `fold` –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–µ–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ `accumulator`, —Ç.–µ. –∏—Å–∫–æ–º—ã–π –≤–µ–∫—Ç–æ—Ä.
–ß—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –µ–≥–æ –≤ —Å–ø–∏—Å–æ–∫ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–ø–∏—à–µ–º `+` –ø–µ—Ä–µ–¥ –ø–æ–ª—É—á–∞–µ–º—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º.

–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º —Å–ø–∏—Å–æ–∫ –∑–∞–ø–æ–ª–Ω—è–µ—Ç—Å—è –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –±–∞–∑–∏—Å–æ–º.

## –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –≤—Å–µ–≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º-–ø—Ä–µ—Ç–µ–Ω–¥–µ–Ω—Ç–æ–≤

–¢–µ–ø–µ—Ä—å –∑–∞–π–º—ë–º—Å—è –ø–æ–ª—É—á–µ–Ω–∏–µ–º –≤—Å–µ–≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º –∏–∑ —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤–∏–¥–∞ $\sum_{i=1}^n \pm x_i = 0$.
–°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± –¥–µ–ª–∞—Ç—å —ç—Ç–æ &mdash; —ç—Ç–æ –ª–∏–Ω–µ–π–Ω—ã–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –≤—Å–µ–≤–æ–∑–º–æ–∂–Ω—ã–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è
–∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å –≤—Å–µ –∏–º–µ—é—â–∏–µ—Å—è —Å–∏—Å—Ç–µ–º—ã (–Ω–µ —É–¥–∞–ª—è—è –∏/–∏–ª–∏ –∏–∑–º–µ–Ω—è—è –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–µ, –∞ –ª–∏—à—å –¥–æ–±–∞–≤–ª—è—è –Ω–æ–≤—ã–µ).

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é:
```kotlin title="computePossibleEquationSystems.kt"
data class EquationCase<Covector>(
    val initialCovectors: KoneList<Covector>,
    val basis: KoneList<Covector>,
)

fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
): KoneList<KoneList<EquationCase<Covector>>> {
    TODO()
}
```
–ó–¥–µ—Å—å `Covector` –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø, –æ–ø–∏—Å—ã–≤–∞—é—â–∏–π —É—Ä–∞–≤–Ω–µ–Ω–∏–µ, —Ç.–µ. –∫–æ–≤–µ–∫—Ç–æ—Ä.
–ü–æ–ª—É—á–∞–µ–º –º—ã (–ø–æ–∫–∞) —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á–∏ (—á–∏—Å–ª–æ $n$),
–∞ –≤—ã–≤–æ–¥–∏–º –≤—Å–µ —Ä–∞–∑—Ä–µ—à–∏–º—ã–µ –Ω–µ—Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º —Å–∏—Å—Ç–µ–º—ã –∏—Å–∫–æ–º–æ–≥–æ –≤–∏–¥–∞,
—Ä–∞–∑–±–∏—Ç—ã–µ –ø–æ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ –Ω–∞ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏.
–¢.–µ. –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å–ø–∏—Å–æ–∫ —Å –∏–Ω–¥–µ–∫—Å–æ–º $i$ –≤–æ –≤–Ω–µ—à–Ω–µ–º –æ–ø–∏—Å—ã–≤–∞–µ—Ç –≤—Å–µ —Å–∏—Å—Ç–µ–º—ã —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ $i$.
–ü–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ —Å–∏—Å—Ç–µ–º—ã –∏–º–µ—é—Ç —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –Ω–µ –±–æ–ª–µ–µ $n$, –Ω–æ –ø—Ä–∏ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ $n-1$ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –∏–º–µ–µ—Ç –Ω–µ—Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π.
–ü–æ—ç—Ç–æ–º—É —Ç–∞–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã –º—ã –±—É–¥–µ–º —Å—Ä–∞–∑—É –æ—Ç–±—Ä–∞—Å—ã–≤–∞—Ç—å,
–∏–∑-–∑–∞ —á–µ–≥–æ –≤–Ω–µ—à–Ω–∏–π —Å–ø–∏—Å–æ–∫ –∏–º–µ–µ—Ç –¥–ª–∏–Ω—É $n$ (–ø–æ –≤—Å–µ–º —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—è–º –æ—Ç $0$ –¥–æ $n-1$).
–ü—Ä–∏ —ç—Ç–æ–º `EquationCase` –æ–ø–∏—Å—ã–≤–∞–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã–µ –∫–æ–≤–µ–∫—Ç–æ—Ä–∞ –≤ —Å–ø–∏—Å–∫–µ `initialCovectors`,
–∞ —Ç–∞–∫–∂–µ –ø–æ–ª—É—á–∞—é—â–∏–π—Å—è –∏–∑ –Ω–∏—Ö –õ–ù–ú `basis`–≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ.
–ú—ã —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ –±—É–¥–µ–º –ø–æ –¥–æ—Ä–æ–≥–µ –≤—ã—á–∏—Å–ª—è—Ç—å —ç—Ç–∏ –õ–ù–ú,
—á—Ç–æ–±—ã —Å—Ä–∞–∑—É –æ—Ç—Å–µ–∏–≤–∞—Ç—å –Ω–µ—Ä–∞–∑—Ä–µ—à–∏–º—ã–µ –Ω–µ—Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã–º –æ–±—Ä–∞–∑–æ–º —Å–∏—Å—Ç–µ–º—ã.
(–ò —á—Ç–æ–±—ã –Ω–µ –≤—ã—á–∏—Å–ª—è—Ç—å –∏—Ö –ø–æ—Ç–æ–º.)

–ú—ã –±—É–¥–µ–º, –ø–µ—Ä–µ–±–∏—Ä–∞—è –≤—Å–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–æ–±–∏—Ä–∞—Ç—å —Å–∏—Å—Ç–µ–º—ã, –Ω–∞—á–∏–Ω–∞—è —Å–æ —Å–ª—É—á–∞—è —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ–π –ø—É—Å—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã.
–ü–æ—ç—Ç–æ–º—É –Ω–∞—á–Ω—ë–º –Ω–∞—à—É —Ñ—É–Ω–∫—Ü–∏—é –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ:
```kotlin title="computePossibleEquationSystems.kt"
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    TODO()

    return equationCases
}
```

–ù–∞—á–∞—Ç—å –ø–µ—Ä–µ–±–æ—Ä –Ω–∞–¥–æ —Å –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏—è —Ç–æ–ª—å–∫–æ –ø—É—Å—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã:
```kotlin title="computePossibleEquationSystems.kt"
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    TODO()

    return equationCases
}
```

–¢–µ–ø–µ—Ä—å –Ω–∞—É—á–∏–º—Å—è –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –≤—Å–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è.
–£—Ä–∞–≤–Ω–µ–Ω–∏—è –∑–∞–¥–∞—é—Ç—Å—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.
–¢–∞–∫ –∫–∞–∫ –∫–∞–∂–¥—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–≤–µ–Ω $1$ –∏–ª–∏ $-1$,
—Ç–æ –Ω–∞–º –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–æ–∑–≤–µ—Å—Ç–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–æ $\{1; -1\}$ –≤ –¥–µ–∫–∞—Ä—Ç—Ç–æ–≤—É —Å—Ç–µ–ø–µ–Ω—å $n$.
–î–ª—è —ç—Ç–æ–≥–æ —É –º–µ–Ω—è –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è `cartesianPower`.
–ù–æ —Ç–∞–∫–∏–µ —É—Ä–∞–≤–Ω–µ–Ω–∏—è –±—å—é—Ç—Å—è –Ω–∞ –ø–∞—Ä—ã —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã—Ö, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –æ–¥–Ω–æ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –∏–∑ –¥—Ä—É–≥–æ–≥–æ –∑–∞–º–µ–Ω–æ–π –∑–Ω–∞–∫–∞ –≤—Å–µ—Ö –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤.
–ß—Ç–æ–±—ã –∏–∑–±–∞–≤–∏—Ç—å—Å—è –æ—Ç —ç—Ç–æ–π –ø—Ä–æ–±–ª–µ–º—ã, —Å–∫–∞–∂–µ–º, —á—Ç–æ –ø–µ—Ä–≤—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –≤—Å–µ–≥–¥–∞ —Ä–∞–≤–µ–Ω $1$.
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º —É –Ω–∞—Å –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Ü–∏–∫–ª
```kotlin title="computePossibleEquationSystems.kt"
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        TODO()
    }

    return equationCases
}
```

–ó–∞–º–µ—Ç–∏–º, —á—Ç–æ —Å–ª—É—á–∞–π –≤—Å–µ—Ö –µ–¥–∏–Ω–∏—Ü –Ω–∞—Å —Ç–æ–∂–µ –Ω–µ —É—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç, —Ç–∞–∫ –∫–∞–∫ –≤ —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ —Ä–µ—à–µ–Ω–∏–π —Å—Ä–∞–∑—É –Ω–µ –±—É–¥–µ—Ç –≤ –∏—Å–∫–æ–º–æ–π –æ–±–ª–∞—Å—Ç–∏.
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue

        TODO()
    }

    return equationCases
}
```

–¢–µ–ø–µ—Ä—å —Å—Ñ–æ—Ä–º–∏—Ä—É–µ–º –∫–æ–≤–µ–∫—Ç–æ—Ä.
–î–ª—è —ç—Ç–æ–≥–æ –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –±–∞–∑–∏—Å –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤ (–∫–æ—Ç–æ—Ä—ã–π –≤ –±—É–¥—É—â–µ–º –±—É–¥–µ—Ç –ø—Ä–æ—Å—Ç—ã–º –±–∞–∑–∏—Å–æ–º –∏–∑ –ø—Ä–æ–µ–∫—Ü–∏–π –Ω–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤–µ–∫—Ç–æ—Ä–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤:
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        TODO()
    }

    return equationCases
}
```

–¢–µ–ø–µ—Ä—å –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–±—Ä–∞—Ç—å –≤—Å–µ –∏–º–µ—é—â–∏–µ—Å—è —Å–∏—Å—Ç–µ–º—ã –∏–∑ `equationCases` –∏ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –æ–±—Ä–∞—Ç–Ω–æ –≤ `equationCases`.
–ì–ª–∞–≤–Ω–æ–µ —Ç—É—Ç &mdash; –Ω–µ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –Ω–æ–≤—ã–µ —Å–∏—Å—Ç–µ–º—ã, —á—Ç–æ –º–æ–∂–µ—Ç —Å–ª—É—á–∏—Ç—å—Å—è –ø—Ä–∏ –ø–µ—Ä–µ–±–∏—Ä–∞–Ω–∏–∏ –∫–æ–ª–ª–µ–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—É—é —Ä–∞—Å—à–∏—Ä—è–µ—à—å.
–î–ª—è —ç—Ç–æ–≥–æ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å—Å—è –ø–æ —Å–ø–∏—Å–∫–∞–º –æ—Ç –±–æ–ª—å—à–µ–≥–æ –ø–æ –∏–Ω–¥–µ–∫—Å—É –∫ –º–µ–Ω—å—à–µ–º—É,
–∫–æ–ø–∏—Ä—É—è –≤ –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ —Ç–æ—Ç, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É —Å–æ–±–∏—Ä–∞–µ–º—Å—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å—Å—è.
–≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç, —Ç–∞–∫ –∫–∞–∫ –ø—Ä–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–∏ —Å–∏—Å—Ç–µ–º—ã –µ—ë —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –ª–∏–±–æ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è (—Ç.–µ. –º—ã –¥–æ–±–∞–≤–∏–º —Å–∏—Å—Ç–µ–º—É –≤ —Ç–æ—Ç –∂–µ —Å–ø–∏—Å–æ–∫),
–ª–∏–±–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É (—Ç.–µ. –æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ).
–ü–æ—ç—Ç–æ–º—É —Ç–∞–∫ –∏ –Ω–∞–ø–∏—à–µ–º:
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in dimension - 1u downTo 0u) for (case in equationCases[dim].toKoneList()) {
            TODO()
        }
    }

    return equationCases
}
```
–ü–æ–¥–º–µ—á—É, —á—Ç–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ –≤—ã–∑–æ–≤–µ `.toKoneList()`.

–¢–µ–ø–µ—Ä—å –Ω–∞–º –Ω—É–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –õ–ù–ú –≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ, –∫–æ—Ç–æ—Ä—ã–π –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º.
–î–ª—è —ç—Ç–æ–≥–æ –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –∞—Ä–≥—É–º–µ–Ω—Ç —Ç–∏–ø–∞ `BasisExtender<Covector>`:
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in dimension - 1u downTo 0u) for (case in equationCases[dim].toKoneList()) {
            val newBasis = case.basis.extend(vector)
            TODO()
        }
    }

    return equationCases
}
```
–ü–æ–ª—É—á–∏–≤ –Ω–æ–≤—ã–π –±–∞–∑–∏—Å, —Å—Ñ–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π `EquationCase` –∏ –¥–æ–±–∞–≤–∏–º –≤ —Å–ø–∏—Å–æ–∫ —Å –∏–Ω–¥–µ–∫—Å–æ–º `newBasis.size`.
–ù–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–∞–∫–æ–π –∏–Ω–¥–µ–∫—Å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.
–ü–æ–ª—É—á–∏—Ç—Å—è —Ç–∞–∫–æ–π –∏—Ç–æ–≥–æ–≤—ã–π –∫–æ–¥:
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in dimension - 1u downTo 0u) for (case in equationCases[dim].toKoneList()) {
            val newBasis = case.basis.extend(vector)
            if (newBasis.size == dimension) continue
            equationCases[newBasis.size].add(
                EquationCase(
                    initialCovectors = KoneList.build(case.initialCovectors.size + 1u) {
                        addAllFrom(case.initialCovectors)
                        add(vector)
                    },
                    basis = newBasis,
                )
            )
        }
    }

    return equationCases
}
```

## –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø–æ–ª–∏—Ç–æ–ø–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ–±—ä—ë–º–æ–≤ —Ñ–∞—Å–µ—Ç —Å–∏–º–ø–ª–µ–∫—Å–∞

–ü–æ –≤—Ç–æ—Ä–æ–º—É –ø—É–Ω–∫—Ç—É –Ω–∞—à–µ–≥–æ –ø–ª–∞–Ω–∞ –Ω—É–∂–Ω–æ –≤ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏ $\sum_{i=1}^n x_i = 1$ –Ω–∞–π—Ç–∏ –≤—Å–µ —Ä–µ–∞–ª–∏–∑—É–µ–º—ã–µ –Ω–∞–±–æ—Ä—ã –æ–±—ä—ë–º–æ–≤ —Ñ–∞—Å–µ—Ç —Å–∏–º–ø–ª–µ–∫—Å–∞.
–ö–∞–∫ –º—ã –ø–æ–º–Ω–∏–º, —ç—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç—å –≤—ã–ø—É–∫–ª–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞, –ø–æ–ª—É—á–∞—é—â–µ–≥–æ—Å—è –ø—Ä–∏ –ø—Ä–æ–≤–µ–¥–µ–Ω–∏–∏ –ø–æ–ª—É–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤,
–∑–∞–¥–∞–≤–∞–µ–º—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏—è–º–∏ –≤–∏–¥–∞ $x_k > 0$ –∏ –≤–∏–¥–∞ $\sum_{i=1}^n x_i > 2 x_k$.
–ó–Ω–∞—á–∏—Ç, –Ω–∞–º –Ω—É–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —ç—Ç–æ—Ç –ø–æ–ª–∏—Ç–æ–ø.
–ü–æ–¥ "–ø–æ—Å—Ç—Ä–æ–∏—Ç—å" –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ—Ç—Å—è "–Ω–∞–π—Ç–∏ –≤—Å–µ –µ–≥–æ –≤–µ—Ä—à–∏–Ω—ã –∫–∞–∫ –ø–æ–ª–æ–∂–µ–Ω–∏—è –≤ –∞—Ñ—Ñ–∏–Ω–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏ –≤—ã–ø–∏—Å–∞—Ç—å –≤—Å–µ –µ–≥–æ –≥—Ä–∞–Ω–∏,
—É–∫–∞–∑–∞–≤ —É –∫–∞–∂–¥–æ–π, –∫–∞–∫–∏–µ –¥—Ä—É–≥–∏–µ –≥—Ä–∞–Ω–∏ —è–≤–ª—è–µ—Ç—Å—è –µ—ë –≥—Ä–∞–Ω—è–º–∏".
–î–ª—è —ç—Ç–æ–≥–æ –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è —Å–ª–µ–¥—É—é—â–∏–º –ø–ª–∞–Ω–æ–º:
1. –°–¥–µ–ª–∞–µ–º –ø–æ–ª–∏—Ç–æ–ø –≤ –∞—Ñ—Ñ–∏–Ω–Ω–æ–º –≥–∏–ø–µ—Ä–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ $\sum_{i=1}^n x_i = 1$, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏ $x_k > 0$.
   –≠—Ç–æ –≤—Å–µ–≥–æ –ª–∏—à—å —Å–∏–º–ø–ª–µ–∫—Å –Ω–∞—Ç—è–Ω—É—Ç—ã–π –Ω–∞ –≤–µ—Ä—à–∏–Ω—ã –≤–∏–¥–∞ $(0, \dots, 0, 1, 0 \dots, 0)$.
2. –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –≤–∏–¥–∞ $\sum_{i=1}^n x_i > 2 x_k$ —Ä–∞–∑—Ä—É–±–∏–º –≤—Å—é –ø–æ–ª–∏—Ç–æ–ø–∏—á–µ—Å–∫—É—é –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
   –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å—é $\sum_{i=1}^n x_i - 2 x_k = 0$ –∏ —É–±–µ—Ä—ë–º –≤—Å–µ –ø–æ–ª–∏—Ç–æ–ø—ã, –Ω–∞—Ö–æ–¥—è—â–∏–µ—Å—è –ø–æ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç —ç—Ç–æ–π –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏.

### üîµ –û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ: —Ä–∞–∑–±–∏–µ–Ω–∏–µ –ø–æ–ª–∏—Ç–æ–ø–∏—á–µ—Å–∫–æ–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –ª–∏–Ω–µ–π–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ –∞—Ñ—Ñ–∏–Ω–Ω–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ

```kotlin title="divideByAndPut.kt"
data class PolytopeAndSign<Polytope>(
    val polytope: Polytope,
    val sign: Sign,
)

@IgnorableReturnValue
context(_: Field<Number>, _: Order<Number>, _: AffineSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> AbstractPolytopicConstruction<Point>.divideByAndPut(
    linearFunction: (Point) -> Number,
    target: AbstractPolytopicConstruction<Point>,
): KoneList<KoneMap<AbstractPolytopicConstruction.Polytope<Point>, KoneList<PolytopeAndSign<AbstractPolytopicConstruction.Polytope<Point>>>>> {
    val vertexMapping = vertices.associateWith(
        keyEquality = Equality.absoluteFor(),
        keyHashing = Hashing.defaultFor(),
        keyOrder = null
    ) { PolytopeAndSign(target.addVertex(it.position), linearFunction(it.position).sign()) }
    val polytopeMapping = KoneArrayFixedCapacityList<KoneMap<AbstractPolytopicConstruction.Polytope<Point>, KoneList<PolytopeAndSign<AbstractPolytopicConstruction.Polytope<Point>>>>>(spaceDimension + 1u)
    polytopeMapping.add(
        vertexMapping.nodesView.associate(
            keyEquality = Equality.absoluteFor(),
            keyHashing = Hashing.defaultFor(),
            keyOrder = null,
        ) { it.key.asPolytope() mapsTo KoneList.of(PolytopeAndSign(it.value.polytope.asPolytope(), it.value.sign)) }
    )

    val edges = polytopesOfDimension(1u)
    val polytopeSectionMapping = KoneArrayFixedCapacityList<KoneMap<AbstractPolytopicConstruction.Polytope<Point>, Maybe<AbstractPolytopicConstruction.Polytope<Point>>>>(spaceDimension)
    polytopeSectionMapping.add(
        edges.associateWith(
            keyEquality = Equality.absoluteFor(),
            keyHashing = Hashing.defaultFor(),
            keyOrder = null,
        ) {
            val (end1, end2) = it.vertices.toKoneList()
            val end1Sign = polytopeMapping[0u][end1.asPolytope()].single().sign
            val end2Sign = polytopeMapping[0u][end2.asPolytope()].single().sign
            if (end1Sign == end2Sign || end1Sign.isZero() || end2Sign.isZero()) None
            else Some(
                target.addVertex(
                    end2.position + (end1.position - end2.position) / (linearFunction(end1.position) - linearFunction(end2.position)) * (-linearFunction(end2.position)),
                ).asPolytope()
            )
        }
    )
    polytopeMapping.add(
        edges.associateWith(
            keyEquality = Equality.absoluteFor(),
            keyHashing = Hashing.defaultFor(),
            keyOrder = null,
        ) {
            val (end1, end2) = it.vertices.toKoneList()
            when (val section = polytopeSectionMapping[0u][it]) {
                None -> KoneList.of(
                    PolytopeAndSign(
                        polytope = target.addPolytope(
                            dimension = 1u,
                            vertices = KoneReifiedSet.of(
                                vertexMapping[end1].polytope, vertexMapping[end2].polytope,
                                elementReification = Reification.defaultFor(),
                                elementEquality = Equality.absoluteFor(),
                                elementHashing = Hashing.defaultFor(),
                                elementOrder = null,
                            ),
                            faces = KoneList.of(
                                KoneReifiedSet.of(
                                    vertexMapping[end1].polytope.asPolytope(), vertexMapping[end2].polytope.asPolytope(),
                                    elementReification = Reification.defaultFor(),
                                    elementEquality = Equality.absoluteFor(),
                                    elementHashing = Hashing.defaultFor(),
                                    elementOrder = null,
                                ),
                            ),
                        ),
                        sign = vertexMapping[end1].sign.takeIf { it.isNonZero() } ?: vertexMapping[end2].sign,
                    ),
                )
                is Some<AbstractPolytopicConstruction.Polytope<Point>> -> KoneList.of(
                    PolytopeAndSign(
                        polytope = target.addPolytope(
                            dimension = 1u,
                            vertices = KoneReifiedSet.of(
                                vertexMapping[end1].polytope, section.value.vertices.single(),
                                elementReification = Reification.defaultFor(),
                                elementEquality = Equality.absoluteFor(),
                                elementHashing = Hashing.defaultFor(),
                                elementOrder = null,
                            ),
                            faces = KoneList.of(
                                KoneReifiedSet.of(
                                    vertexMapping[end1].polytope.asPolytope(), section.value,
                                    elementReification = Reification.defaultFor(),
                                    elementEquality = Equality.absoluteFor(),
                                    elementHashing = Hashing.defaultFor(),
                                    elementOrder = null,
                                ),
                            ),
                        ),
                        sign = vertexMapping[end1].sign
                    ),
                    PolytopeAndSign(
                        polytope = target.addPolytope(
                            dimension = 1u,
                            vertices = KoneReifiedSet.of(
                                vertexMapping[end2].polytope, section.value.vertices.single(),
                                elementReification = Reification.defaultFor(),
                                elementEquality = Equality.absoluteFor(),
                                elementHashing = Hashing.defaultFor(),
                                elementOrder = null,
                            ),
                            faces = KoneList.of(
                                KoneReifiedSet.of(
                                    vertexMapping[end2].polytope.asPolytope(), section.value,
                                    elementReification = Reification.defaultFor(),
                                    elementEquality = Equality.absoluteFor(),
                                    elementHashing = Hashing.defaultFor(),
                                    elementOrder = null,
                                ),
                            ),
                        ),
                        sign = vertexMapping[end2].sign
                    ),
                )
            }
        }
    )

    for (dim in 2u .. spaceDimension) {
        val polytopes = polytopesOfDimension(dim)
        polytopeSectionMapping.add(
            polytopes.associateWith(
                keyEquality = Equality.absoluteFor(),
                keyHashing = Hashing.defaultFor(),
                keyOrder = null,
            ) { polytope ->
                val signs = polytope.vertices.map { vertexMapping[it].sign }

                if (signs.all { it.isNonNegative() } || signs.all { it.isNonPositive() }) return@associateWith None

                Some(
                    target.addPolytope(
                        dimension = dim - 1u,
                        vertices = KoneReifiedSet.build(
                            elementReification = Reification.defaultFor(),
                            elementEquality = Equality.absoluteFor(),
                            elementHashing = Hashing.defaultFor(),
                            elementOrder = null,
                        ) {
                            polytope.facesOfDimension(1u).mapSomeTo(this) {
                                polytopeSectionMapping[0u][it].map { it.vertices.single() }
                            }
                            polytope.vertices.map { vertexMapping[it] }.filter { it.sign.isZero() }.mapTo(this) { it.polytope }
                        },
                        faces = KoneList(dim - 1u) { subdim ->
                            KoneReifiedSet.build(
                                elementReification = Reification.defaultFor(),
                                elementEquality = Equality.absoluteFor(),
                                elementHashing = Hashing.defaultFor(),
                                elementOrder = null,
                            ) {
                                polytope.facesOfDimension(subdim + 1u).mapSomeTo(this) {
                                    polytopeSectionMapping[subdim][it]
                                }
                                polytope.facesOfDimension(subdim).flatMapTo(this) { polytopeMapping[subdim][it].filter { it.sign.isZero() }.map { it.polytope } }
                            }
                        },
                    )
                )
            }
        )
        polytopeMapping.add(
            polytopes.associateWith(
                keyEquality = Equality.absoluteFor(),
                keyHashing = Hashing.defaultFor(),
                keyOrder = null,
            ) { polytope ->
                when (val section = polytopeSectionMapping[dim - 1u][polytope]) {
                    None -> KoneList.of(
                        PolytopeAndSign(
                            polytope = target.addPolytope(
                                dimension = dim,
                                vertices = polytope.vertices.mapTo(
                                    KoneMutableReifiedSet.of(
                                        elementReification = Reification.defaultFor(),
                                        elementEquality = Equality.absoluteFor(),
                                        elementHashing = Hashing.defaultFor(),
                                        elementOrder = null,
                                    )
                                ) { vertexMapping[it].polytope },
                                faces = KoneList(dim) { subdim ->
                                    polytope.facesOfDimension(subdim).mapTo(
                                        KoneMutableReifiedSet.of(
                                            elementReification = Reification.defaultFor(),
                                            elementEquality = Equality.absoluteFor(),
                                            elementHashing = Hashing.defaultFor(),
                                            elementOrder = null,
                                        )
                                    ) { polytopeMapping[subdim][it].single().polytope }
                                }
                            ),
                            sign = polytope.vertices.firstOfThatOrNull({ vertexMapping[it].sign }) { it.isNonZero() } ?: Sign.Zero,
                        ),
                    )
                    is Some<AbstractPolytopicConstruction.Polytope<Point>> -> KoneList.of(
                        PolytopeAndSign(
                            polytope = target.addPolytope(
                                dimension = dim,
                                vertices = KoneReifiedSet.build(
                                    elementReification = Reification.defaultFor(),
                                    elementEquality = Equality.absoluteFor(),
                                    elementHashing = Hashing.defaultFor(),
                                    elementOrder = null,
                                ) {
                                    addAllFrom(section.value.vertices)
                                    polytope.vertices.map { vertexMapping[it] }.filter { it.sign.isNonNegative() }.mapTo(this) { it.polytope }
                                },
                                faces = KoneList(dim) { subdim ->
                                    KoneReifiedSet.build(
                                        elementReification = Reification.defaultFor(),
                                        elementEquality = Equality.absoluteFor(),
                                        elementHashing = Hashing.defaultFor(),
                                        elementOrder = null,
                                    ) {
                                        if (subdim < dim - 1u) addAllFrom(section.value.facesOfDimension(subdim))
                                        else add(section.value)
                                        polytope.facesOfDimension(subdim).flatMapTo(this) { polytopeMapping[subdim][it].filter { it.sign.isNonNegative() }.map { it.polytope } }
                                    }
                                },
                            ),
                            sign = Sign.Positive,
                        ),
                        PolytopeAndSign(
                            polytope = target.addPolytope(
                                dimension = dim,
                                vertices = KoneReifiedSet.build(
                                    elementReification = Reification.defaultFor(),
                                    elementEquality = Equality.absoluteFor(),
                                    elementHashing = Hashing.defaultFor(),
                                    elementOrder = null,
                                ) {
                                    addAllFrom(section.value.vertices)
                                    polytope.vertices.map { vertexMapping[it] }.filter { it.sign.isNonPositive() }.mapTo(this) { it.polytope }
                                },
                                faces = KoneList(dim) { subdim ->
                                    KoneReifiedSet.build(
                                        elementReification = Reification.defaultFor(),
                                        elementEquality = Equality.absoluteFor(),
                                        elementHashing = Hashing.defaultFor(),
                                        elementOrder = null,
                                    ) {
                                        if (subdim < dim - 1u) addAllFrom(section.value.facesOfDimension(subdim))
                                        else add(section.value)
                                        polytope.facesOfDimension(subdim).flatMapTo(this) { polytopeMapping[subdim][it].filter { it.sign.isNonPositive() }.map { it.polytope } }
                                    }
                                },
                            ),
                            sign = Sign.Negative,
                        ),
                    )
                }
            }
        )
    }

    return polytopeMapping
}
```

### –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Å–∏–º–ø–ª–µ–∫—Å–∞ –Ω–∞ —Ç–æ—á–∫–∞—Ö –≤–∏–¥–∞ $(0, \dots, 0, 1, 0 \dots, 0)$

–¢—É—Ç –≤—Å—ë –¥–æ–≤–æ–ª—å–Ω–æ –ø—Ä–æ—Å—Ç–æ: –Ω—É–∂–Ω–æ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –ø–æ –ø–æ–¥—Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ —Å—Ç—Ä–æ–∏—Ç—å –≤—Å–µ –≥—Ä–∞–Ω–∏ –¥–∞–Ω–Ω–æ–π –ø–æ–¥—Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏.
–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –ø–æ –ø–æ–¥—Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏, —Ç–∞–∫ –∫–∞–∫ —á—Ç–æ–±—ã –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞–Ω—å –∫–∞–∫–æ–π –±—ã —Ç–æ –Ω–∏ –±—ã–ª–æ –ø–æ–¥—Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏, –Ω—É–∂–Ω–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≤—Å–µ –µ—ë –≥—Ä–∞–Ω–∏.

```kotlin title="defaultSimplex.kt"
fun <Number, Vector> defaultSimplex(
    dimension: UInt,
    basis: VectorSpaceBasis.Finite<Number, Vector>,
): AbstractPolytopicConstruction<PointWrapper<Vector>> =
    AbstractPolytopicConstruction<PointWrapper<Vector>>(dimension).apply {
        val vertices = KoneList(dimension) { index -> addVertex(PointWrapper(basis[index])) }
        val faces = KoneArrayFixedCapacityList<KoneMap<KoneList<UInt>, AbstractPolytopicConstruction.Polytope<PointWrapper<Vector>>>>(dimension)
        faces.add(
            vertices.withIndex().associate(
                keyEquality = KoneList.equality(UInt.context),
                keyHashing = KoneList.hashing(UInt.context),
            ) { (index, vertex) ->
                KoneList(dimension) { if (it == index) 1u else 0u } mapsTo vertex.asPolytope()
            }
        )
        for (dim in 2u .. dimension) faces.add(
            KoneMap.build(
                keyEquality = KoneList.equality(UInt.context),
                keyHashing = KoneList.hashing(UInt.context),
            ) {
                for (flags in KoneList(dimension) { if (it < dim) 1u else 0u }.permutationsWithoutRepetitions(
                    equality = UInt.context
                ))
                    this[flags] = addPolytope(
                        dimension = dim - 1u,
                        vertices = KoneReifiedSet.build(
                            elementEquality = Equality.absoluteFor(),
                            elementHashing = Hashing.defaultFor(),
                        ) {
                            for ((index, flag) in flags.withIndex()) if (flag == 1u) add(vertices[index])
                        },
                        faces = KoneList(dim - 1u) {
                            KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<PointWrapper<Vector>>>(
                                elementEquality = Equality.absoluteFor(),
                                elementHashing = Hashing.defaultFor(),
                            )
                        }.apply {
                            for (subflags in cartesianProduct(flags.map { (0u .. it).toKoneList() })) if (UInt.context { subflags.sum() } in 1u ..< dim)
                                this[UInt.context { subflags.sum() } - 1u].add(faces[UInt.context { subflags.sum() } - 1u][subflags])
                        }
                    )
            }
        )
    }
```

### –§–∏–Ω–∞–ª—å–Ω—ã–π –ø–æ–ª–∏—Ç–æ–ø

```kotlin title="areaToCheckIntersectionWith.kt"
context(_: Field<Number>, _: Order<Number>, _: AffineSpaceOverField<Number, Vector, PointWrapper<Vector>>)
fun <Number, Vector> areaToCheckIntersectionWith(
    dimension: UInt,
    basis: VectorSpaceBasis.Finite<Number, Vector>
): AbstractPolytopicConstruction.Polytope<PointWrapper<Vector>> {
    var polytopicConstruction = defaultSimplex(dimension, basis)

    for (index in 0u ..< dimension) {
        val newPolytopicConstruction = AbstractPolytopicConstruction<PointWrapper<Vector>>(dimension)

        val polytopeMapping = polytopicConstruction.divideByAndPut(
            linearFunction = {  point ->
                val vectorDecomposition = basis.decompose(point.vector)
                context(contextOf<Monoid<Number>>()) {
                    (0u ..< dimension).toKoneList().sumOf { vectorDecomposition[it] } - vectorDecomposition[index] * 2
                }
            },
            target = newPolytopicConstruction
        )

        for (vertexPolytope in polytopeMapping[0u].valuesView.flatMap { it.filter { it.sign.isNegative() }.map { it.polytope } })
            vertexPolytope.remove()

        polytopicConstruction = newPolytopicConstruction
    }

    return polytopicConstruction.polytopesOfDimension(dimension - 1u).single()
}
```

## üîµ –û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ: –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –±–∞–∑–∏—Å–∞ —Ä–µ—à–µ–Ω–∏–π —Å–∏—Å—Ç–µ–º—ã —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ

–ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Ä–µ—à–µ–Ω–∏–π –¥–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã —É—Ä–∞–≤–Ω–µ–Ω–∏–π (–≤ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–º —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–º –≤–∏–¥–µ)
–≤ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏ $\sum_{i=1}^n x_i = 1$ —Å –ø–æ–ª–∏—Ç–æ–ø–æ–º –≤–æ–∑–º–æ–∂–Ω—ã—Ö –æ–±—ä—ë–º–æ–≤ —Ñ–∞—Å–µ—Ç —Å–∏–º–ø–ª–µ–∫—Å–∞,
–Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—ã—Ä–∞–∑–∏—Ç—å —ç—Ç–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ä–µ—à–µ–Ω–∏–π –∫–∞–∫ –∞—Ñ—Ñ–∏–Ω–Ω—É—é –æ–±–æ–ª–æ—á–∫—É –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ç–æ—á–µ–∫ (–≤–æ –≤—Å—ë —Ç–æ–π –∂–µ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏).
–î–ª—è —ç—Ç–æ–≥–æ —Å—Ç–æ–∏—Ç –≤—ã—á–∏—Å–ª–∏—Ç—å –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å –±–∞–∑–∏—Å —ç—Ç–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ —Ä–µ—à–µ–Ω–∏–π –∏ "—Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å" –µ–≥–æ –Ω–∞ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å.
–ó–∞–π–º—ë–º—Å—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–µ–º –±–∞–∑–∏—Å–∞.

(–ë—É–¥–µ–º –∑–∞–¥–∞–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É —É—Ä–∞–≤–Ω–µ–Ω–∏–π –º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –∏–∑ $m$ –≤–µ–∫—Ç–æ—Ä–æ–≤-—Å—Ç—Ä–æ–∫ $v_t = (v_{t, i})_{i=1}^n$,
–¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö –∏—â–µ–º –≤–µ–∫—Ç–æ—Ä-—Å—Ç–æ–ª–±–µ—Ü $a$, —á—Ç–æ $v_t \cdot a = (0)$.)
–ü–æ—Å–∫–æ–ª—å–∫—É –Ω–∞—à–∞ —Å–∏—Å—Ç–µ–º–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–π –ø—Ä–∏–≤–µ–¥–µ–Ω–∞ –∫ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–π —Ñ–æ—Ä–º–µ —Å–æ —Å—Ç—É–ø–µ–Ω—å–∫–∞–º–∏ –≤ —Å—Ç–æ–ª–±—Ü–∞—Ö $k_1$, ..., $k_m$,
—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ —Å –Ω–æ–º–µ—Ä–æ–º $i \in (k_t, k_{t+1})$ –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å —Å—Ç–æ–ª–±–µ—Ü $a = (a_1, \dots, a_n)^T$, –≥–¥–µ
$$
    a_j =
    \begin{cases}
        v_{s,i}& \text{–µ—Å–ª–∏ } j = k_s, s \leqslant t\\
        -1& \text{–µ—Å–ª–∏ } j = i\\
        0& \text{–∏–Ω–∞—á–µ}
    \end{cases}
$$
–¢–æ–≥–¥–∞ –∏–∑ —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ—Å—Ç–∏ –±—É–¥–µ—Ç –ø–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ –¥–ª—è –≤—Å–µ—Ö $s > t$ –≤–µ—Ä–Ω–æ $v_s \cdot a = (0)$,
—Ç–∞–∫ –∫–∞–∫ –≤—Å–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã $v_s$ —Ä–∞–≤–Ω—ã –Ω—É–ª—é –¥–æ —Å—Ç–æ–ª–±—Ü–∞ $k_s$ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ,
–∞ –≤—Å–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã $a$ —Ä–∞–≤–Ω—ã –Ω—É–ª—é —Å–æ —Å—Ç—Ä–æ–∫–∏ $i < k_{i+1} \leqslant k_s$ –∏—Å–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ.
–¢–∞–∫–∂–µ –∏–∑ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ—Å—Ç–∏ –ø–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ –¥–ª—è –≤—Å–µ—Ö $s \leqslant t$ –≤–µ—Ä–Ω–æ $v_s \cdot a = (0)$,
—Ç–∞–∫ –∫–∞–∫ $v_s$ –∏–º–µ–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ –Ω–µ–Ω—É–ª–µ–≤—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –≤ —Å—Ç–æ–ª–±—Ü–∞—Ö $k_1$, ..., $k_t$ –∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç $-1$ –≤ —Å—Ç–æ–ª–±—Ü–µ $i$,
–Ω–æ $v_s$ –∏–º–µ–µ—Ç –≤–æ –≤—Å–µ—Ö —ç—Ç–∏—Ö —Å—Ç–æ–ª–±—Ü–∞—Ö –∫—Ä–æ–º–µ $k_s$ –∏, –±—ã—Ç—å –º–æ–∂–µ—Ç, $i$ –Ω—É–ª–µ–≤—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã,
–æ—Ç—á–µ–≥–æ
$$
    v_s \cdot a = (v_{s, k_s} \cdot a_{k_s} + v_{s, i} \cdot a_i) = (1 \cdot v_{s, i} + v_{s, i} \cdot (-1)) = (0)
$$
–ü—Ä–∏ —ç—Ç–æ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –Ω–µ–Ω—É–ª–µ–≤–æ–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç $a$ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Å—Ç—Ä–æ–∫–µ $i$.
–ó–Ω–∞—á–∏—Ç, –¥–ª—è –≤—Å–µ—Ö $i \notin \{k_t\}_{t=1}^m$ –±—É–¥–µ—Ç –ø–æ–ª—É—á–∞—Ç—å—Å—è –ø–æ –≤–µ–∫—Ç–æ—Ä—É $a$, –∏ –≤—Å–µ —ç—Ç–∏ –≤–µ–∫—Ç–æ—Ä—ã –±—É–¥—É—Ç –ª–∏–Ω–µ–π–Ω–æ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã.

### –ü—Ä–æ–≥—Ä–∞–º–º–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é.
```kotlin title="reducedRowEchelonFormKernel.kt"
fun <
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
): KoneList<Vector> {
    TODO()
}
```

–ü–æ—Å–∫–æ–ª—å–∫—É –º—ã –±—É–¥–µ–º —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –∫–æ–≤–µ–∫—Ç–æ—Ä–∞ –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –±–∞–∑–∏—Å—É (—á—Ç–æ–±—ã —Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –∏—Ö –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã),
–∞ —Ç–∞–∫–∂–µ –±—É–¥–µ–º —Å–æ–±–∏—Ä–∞—Ç—å –≤–µ–∫—Ç–æ—Ä–∞ –ø–æ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º –ø—Ä–∏ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–∏ –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–º—É –±–∞–∑–∏—Å—É,
—Ç–æ –Ω–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —Ç–∏–ø —á–∏—Å–µ–ª `Number` –∏ –µ—â—ë –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤:
```kotlin title="reducedRowEchelonFormKernel.kt"
context(_: Field<Number>, vectorSpace: VectorSpace<Number, Vector>)
fun <
    Number,
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasisDecomposition: VectorSpaceBasisDecomposition.Finite<Number, Covector>,
): KoneList<Vector> {
    TODO()
}
```

–î–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ø–µ—Ä–µ–ª–æ–∂–∏–º –∫–æ–≤–µ–∫—Ç–æ—Ä–∞ –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é `cobasis`.
–ò –∑–∞–æ–¥–Ω–æ —Å—Ä–∞–∑—É –≤–µ—Ä–Ω—ë–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –∫–∞–∫ —Å–ø–∏—Å–æ–∫ –≤–µ–∫—Ç–æ—Ä–æ–≤ (–∫–æ—Ç–æ—Ä—ã–π –º—ã –ø–æ–∫–∞ –Ω–µ —É–º–µ–µ–º —Å—Ç—Ä–æ–∏—Ç—å).
```kotlin title="reducedRowEchelonFormKernel.kt"
context(_: Field<Number>, vectorSpace: VectorSpace<Number, Vector>)
fun <
    Number,
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasisDecomposition: VectorSpaceBasisDecomposition.Finite<Number, Covector>,
): KoneList<Vector> {
    val cobasis = this
    return KoneList.build(dimension - cobasis.size) {
        TODO()
    }
}
```

–î–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤ –ø–æ –ø—Ä–∏–Ω—Ü–∏–ø—É –æ–ø–∏—Å–∞–Ω–Ω–æ–º –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –Ω–∞–º –Ω—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏—Å—å –ø–æ –≤—Å–µ–º —Å—Ç–æ–ª–±—Ü–∞–º
–∏, –µ—Å–ª–∏ —ç—Ç–æ—Ç —Å—Ç–æ–ª–±–µ—Ü –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Å—Ç–æ–ª–±—Ü–æ–º —Å—Ç—É–ø–µ–Ω—å–∫–∏, –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –µ–º—É –≤–µ–∫—Ç–æ—Ä.
–î–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∞–∫–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ –Ω—É–∂–Ω–æ –ø–æ–Ω—è—Ç—å, –∫–∞–∫–∏–µ –ø–µ—Ä–µ–¥ —ç—Ç–∏–º –±—ã–ª–∏ —Å—Ç—É–ø–µ–Ω—å–∫–∏.
–ü–æ—ç—Ç–æ–º—É –±—É–¥–µ–º –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–∞ –∫–∞–∂–¥–æ–º –Ω–æ–≤–æ–º —Å—Ç–æ–ª–±—Ü–µ –ª–∏–±–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—É—é —Å—Ç—É–ø–µ–Ω—å–∫—É, –ª–∏–±–æ –≥–µ–Ω–µ—Ä–∏—Ç—å –≤–µ–∫—Ç–æ—Ä.
–ü–æ—ç—Ç–æ–º—É —Å–Ω–∞—á–∞–ª–∞ —Ç–æ—á–Ω–æ –∑–∞–≤–µ–¥—ë–º —Å–ø–∏—Å–æ–∫ `startIndices` –ø–æ–¥ –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Å—Ç–æ–ª–±—Ü—ã —Å—Ç—É–ø–µ–Ω–µ–∫
–∏ –∏–Ω–¥–µ–∫—Å `basisIndex` —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–π –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç —Å—Ç—Ä–æ–∫–∏ (–∏–ª–∏ –ø—Å–µ–≤–¥–æ-—Å—Ç—Ä–æ–∫–∏ —Å –∏–Ω–¥–µ–∫—Å–æ–º $m$),
–≤ –∫–æ—Ç–æ—Ä–æ–π –º—ã –µ—â—ë –Ω–µ –¥–æ—à–ª–∏ –¥–æ —Å—Ç—É–ø–µ–Ω—å–∫–∏ –∏ –Ω–∞—á–Ω—ë–º –∏—Ç–µ—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è –ø–æ —Å—Ç–æ–ª–±—Ü–∞–º.
```kotlin title="reducedRowEchelonFormKernel.kt"
context(_: Field<Number>, vectorSpace: VectorSpace<Number, Vector>)
fun <
    Number,
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasisDecomposition: VectorSpaceBasisDecomposition.Finite<Number, Covector>,
): KoneList<Vector> {
    val cobasis = this
    return KoneList.build(dimension - cobasis.size) {
        val startIndices = KoneArrayFixedCapacityList<UInt>(cobasis.size)
        var basisIndex = 0u
        for (coefficientIndex in 0u ..< dimension) {
            TODO()
        }
    }
}
```

–ü—É—Å—Ç—å –º—ã –ø–æ–ø–∞–ª–∏ –Ω–∞ –Ω–∞—á–∞–ª–æ —Å—Ç—É–ø–µ–Ω—å–∫–∏.
–ß—Ç–æ–±—ã —ç—Ç–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å, —á—Ç–æ –≤ —Å—Ç—Ä–æ–∫–µ —Å –∏–Ω–¥–µ–∫—Å–æ–º `basisIndex` (–µ—Å–ª–∏ —Ç–∞–∫–∞—è –≤–æ–æ–±—â–µ –µ—Å—Ç—å)
–∏ –≤ —Å—Ç–æ–ª–±—Ü–µ —Å –∏–Ω–¥–µ–∫—Å–æ–º `coefficientIndex` —Å—Ç–æ–∏—Ç —á—Ç–æ-—Ç–æ –Ω–µ–Ω—É–ª–µ–≤–æ–µ.
–ü–æ–ø–∞–≤ –Ω–∞ –Ω–∞—á–∞–ª–æ —Å—Ç—É–ø–µ–Ω—å–∫–∏, –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ —Ç–∞–º —Å—Ç–æ–∏—Ç –µ–¥–∏–Ω–∏—Ü–∞, –¥–æ–±–∞–≤–∏–º —ç—Ç–æ—Ç —Å—Ç–æ–ª–±–µ—Ü –≤ `startIndices`
–∏ –ø–µ—Ä–µ–π–¥—ë–º –∫ —Å–ª–µ–¥—É—é—â–∏–º —Å—Ç—Ä–æ–∫–µ –∏ —Å—Ç–æ–ª–±—Ü—É.
```kotlin title="reducedRowEchelonFormKernel.kt"
context(_: Field<Number>, vectorSpace: VectorSpace<Number, Vector>)
fun <
    Number,
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasisDecomposition: VectorSpaceBasisDecomposition.Finite<Number, Covector>,
): KoneList<Vector> {
    val cobasis = this
    return KoneList.build(dimension - cobasis.size) {
        val startIndices = KoneArrayFixedCapacityList<UInt>(cobasis.size)
        var basisIndex = 0u
        for (coefficientIndex in 0u ..< dimension) {
            if (basisIndex < cobasis.size && covectorBasisDecomposition.decompose(cobasis[basisIndex])[coefficientIndex].isNotZero()) {
                check(covectorBasisDecomposition.decompose(cobasis[basisIndex])[coefficientIndex].isOne())
                startIndices.add(coefficientIndex)
                basisIndex++
                continue
            }

            TODO()
        }
    }
}
```

–¢–µ–ø–µ—Ä—å –º—ã —Ç–æ—á–Ω–æ –Ω–∞—Ö–æ–¥–∏–º—Å—è –Ω–∏–∂–µ –æ–¥–Ω–æ–π —Å—Ç—É–ø–µ–Ω—å–∫–∏ –∏ –ª–µ–≤–µ–µ —Å–ª–µ–¥—É—é—â–µ–π.
–¢–æ–≥–¥–∞ —Å–æ–±–µ—Ä—ë–º –≤–µ–∫—Ç–æ—Ä –∫–∞–∫ –æ–ø–∏—Å–∞–Ω–æ –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –∏ –¥–æ–±–∞–≤–∏–º –µ–≥–æ –≤ —Å—Ç—Ä–æ–∏–º—ã–π —Å–ø–∏—Å–æ–∫.
```kotlin title="reducedRowEchelonFormKernel.kt"
context(_: Field<Number>, vectorSpace: VectorSpace<Number, Vector>)
fun <
    Number,
    Vector,
    Covector,
> KoneList<Covector>.reducedRowEchelonFormKernel(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasisDecomposition: VectorSpaceBasisDecomposition.Finite<Number, Covector>,
): KoneList<Vector> {
    val cobasis = this
    return KoneList.build(dimension - cobasis.size) {
        val startIndices = KoneArrayFixedCapacityList<UInt>(cobasis.size)
        var basisIndex = 0u
        for (coefficientIndex in 0u ..< dimension) {
            if (basisIndex < cobasis.size && covectorBasisDecomposition.decompose(cobasis[basisIndex])[coefficientIndex].isNotZero()) {
                check(covectorBasisDecomposition.decompose(cobasis[basisIndex])[coefficientIndex].isOne())
                startIndices.add(coefficientIndex)
                basisIndex++
                continue
            }

            var vector = vectorSpace.zero
            for ((index, start) in startIndices.withIndex())
                vector += covectorBasisDecomposition.decompose(cobasis[index])[coefficientIndex] * vectorBasis[start]
            vector += valueOf(-1) * vectorBasis[coefficientIndex]

            add(vector)
        }
    }
}
```

## üîµ –û—Ç—Å—Ç—É–ø–ª–µ–Ω–∏–µ: –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º–æ—Å—Ç–∏ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ –∏ –¥–∞–Ω–Ω–æ–≥–æ –≤—ã–ø—É–∫–ª–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞ –≤ –¥–∞–Ω–Ω–æ–º –∞—Ñ—Ñ–∏–Ω–Ω–æ–º –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ

–î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–≥–æ, —á—Ç–æ —Å–∏—Å—Ç–µ–º–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–π –∏–º–µ–µ—Ç —Ä–µ—à–µ–Ω–∏—è –≤ –æ–±–ª–∞—Å—Ç–∏, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –Ω–∞–±–æ—Ä–æ–º –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤,
–º—ã –±—É–¥–µ–º –ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –≤—Å—ë –Ω–∞ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å $\sum_{i=1}^n x_i = 1$,
—Ç–∞–∫ –∫–∞–∫ –∏ —É—Ä–∞–≤–Ω–µ–Ω–∏—è, –∏ –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞ –æ–¥–Ω–æ—Ä–æ–¥–Ω—ã –ø–æ –≤–µ–∫—Ç–æ—Ä—É $(x_i)_{i=1}^n$.
–í —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ –æ–±–ª–∞—Å—Ç—å, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–∞–º–∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç—å—é –≤—ã–ø—É–∫–ª–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞,
–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ä–µ—à–µ–Ω–∏–π —Å–∏—Å—Ç–µ–º—ã —É—Ä–∞–≤–Ω–µ–Ω–∏–π –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –∞—Ñ—Ñ–∏–Ω–Ω–æ–µ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–∞–Ω–Ω–æ–π –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç–∏.
–ü–æ–ª—É—á–∞–µ—Ç—Å—è, —á—Ç–æ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –æ–¥–Ω–æ–≥–æ –∏ —Ç–æ–≥–æ –∂–µ –≤—ã–ø—É–∫–ª–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞
–∏ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ (–∫–∞–∂–¥—ã–π —Ä–∞–∑ –Ω–æ–≤–æ–≥–æ) –∞—Ñ—Ñ–∏–Ω–Ω–æ–≥–æ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞.

–†–µ—à–µ–Ω–∏–µ —ç—Ç–æ–π –∑–∞–¥–∞—á–∏ –±—É–¥–µ—Ç —Ä–µ—à–∞—Ç—å—Å—è —Å –ø–æ–º–æ—â—å—é —Ç–∞–∫–æ–π –∏–¥–µ–∏.
–ï—Å–ª–∏ –∞—Ñ—Ñ–∏–Ω–Ω–æ–µ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ &mdash; —Ç–æ—á–∫–∞, —Ç–æ –ø—Ä–æ—Å—Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –ø–æ–ª–∏—Ç–æ–ø–∞.
–ò–Ω–∞—á–µ –≤–æ–∑—å–º—ë–º —Ç–æ—á–∫—É $O$ —ç—Ç–æ–≥–æ –∞—Ñ—Ñ–∏–Ω–Ω–æ–≥–æ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ —Å—Ç—Ä–æ–≥–æ –≤–Ω–µ –ø–æ–ª–∏—Ç–æ–ø–∞
(–∞ —Ç–∞–∫–∞—è –±—É–¥–µ—Ç –≤ —Å–≤—è–∑–∏ —Å –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ—Å—Ç—å—é –ø–µ—Ä–≤–æ–≥–æ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ—Å—Ç—å—é –≤—Ç–æ—Ä–æ–≥–æ),
–Ω–∞–π–¥—ë–º –∫–∞–∫—É—é-–Ω–∏–±—É–¥—å –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å, —á—Ç–æ –ø—Ä–∏ –ø—Ä–æ–µ–∫—Ü–∏–∏ –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞ —á–µ—Ä–µ–∑ $O$ –Ω–∞ –Ω–µ—ë –±—É–¥–µ—Ç –Ω–æ–≤—ã–º –≤—ã–ø—É–∫–ª—ã–º –ø–æ–ª–∏—Ç–æ–ø–æ–º.
–û—Ç—á–µ–≥–æ –º–æ–∂–Ω–æ —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –∏ –∞—Ñ—Ñ–∏–Ω–Ω–æ–µ –ø–æ–¥–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –Ω–∞ —ç—Ç—É –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å, –∑–∞–¥–∞–≤ –±—É–∫–≤–∞–ª—å–Ω–æ —Ç–æ—Ç –∂–µ –≤–æ–ø—Ä–æ—Å –¥–ª—è –Ω–∞ 1 –º–µ–Ω—å—à–µ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏.

–ù–æ —Å–Ω–∞—á–∞–ª–∞ –¥–ª—è –≤—Å–µ–≥–æ —ç—Ç–æ–≥–æ –Ω–∞–º –ø–æ–Ω–∞–¥–æ–±—è—Ç—Å—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —à–∞–≥–∏.

### –®–∞–≥: –Ω–∞–π—Ç–∏ –ª—é–±–æ–π —Ñ–ª–∞–≥ –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞

–≠—Ç–æ—Ç —à–∞–≥ –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç: –ø—Ä–æ—Å—Ç–æ –ø–æ–ª–æ–∂–∏–º –≤ —Å–ø–∏—Å–æ–∫ –Ω–∞—à –ø–æ–ª–∏—Ç–æ–ø –∏,
–ø–æ–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–æ–ª–∏—Ç–æ–ø –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –≤–µ—Ä—à–∏–Ω–æ–π, –±—É–¥–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å –∫–∞–∫—É—é-–Ω–∏–±—É–¥—å —Ñ–∞—Å–µ—Ç—É –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞ –≤ —Å–ø–∏—Å–æ–∫,
–∞ –≤ –∫–æ–Ω—Ü–µ —Ä–∞–∑–≤–µ—Ä–Ω—ë–º —Å–ø–∏—Å–æ–∫ (—á—Ç–æ–±—ã –æ–Ω —à—ë–ª –æ—Ç –≤–µ—Ä—à–∏–Ω—ã –∫ –ø–æ–ª–∏—Ç–æ–ø—É).

```kotlin title="anyFlag.kt"
fun <
    Polytope: PolytopicConstruction.Polytope<*, Polytope, *>
> Polytope.anyFlag(): KoneList<Polytope> =
    KoneList.build {
        add(this@anyFlag)
        repeat(this@anyFlag.dimension) {
            val lastPolytope = last()
            +lastPolytope.facesOfDimension(lastPolytope.dimension - 1u).first()
        }
        reverse()
    }
```

### –®–∞–≥: –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞ –∏ –µ–≥–æ –≥—Ä–∞–Ω–∏ –Ω–∞–π—Ç–∏ –≤ –µ–≥–æ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ –≤–µ–∫—Ç–æ—Ä, –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—ã–π –¥–∞–Ω–Ω–æ–π –≥—Ä–∞–Ω–∏

–í —ç—Ç–æ–º —à–∞–≥–µ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç—Å—è –Ω–∞–π—Ç–∏ –±–∞–∑–∏—Å –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏ –≥—Ä–∞–Ω–∏,
–Ω–∞–π—Ç–∏ –≤–µ–∫—Ç–æ—Ä –∏–¥—É—â–∏–π –∏–∑ –≤–µ—Ä—à–∏–Ω—ã –≥—Ä–∞–Ω–∏ –≤ –≤–µ—Ä—à–∏–Ω—É –ø–æ–ª–∏—Ç–æ–ø–∞ –≤–Ω–µ —ç—Ç–æ–π –≥—Ä–∞–Ω–∏,
–æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ –ì—Ä–∞–º—É-–®–º–∏–¥—Ç—É –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä –≤–º–µ—Å—Ç–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º –±–∞–∑–∏—Å–æ–º
–∏ –ø—Ä–æ—Å—Ç–æ –≤–µ—Ä–Ω—É—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π –∏—Ç–æ–≥–æ–≤—ã–π –≤–µ–∫—Ç–æ—Ä.
–ß—Ç–æ–±—ã –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –±–∞–∑–∏—Å –≤ –≥—Ä–∞–Ω–∏, –º—ã –≤–æ–∑—å–º—ë–º —Ñ–ª–∞–≥ –≥—Ä–∞–Ω–∏,
–≤–æ–∑—å–º—ë–º –µ–≥–æ –Ω–∞—á–∞–ª—å–Ω—É—é –≤–µ—Ä—à–∏–Ω—É –∫–∞–∫ –Ω–∞—á–∞–ª–æ –≤–µ–∫—Ç–æ—Ä–æ–≤,
–∞ –¥–∞–ª—å—à–µ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã —Å–æ—Å–µ–¥–Ω–∏—Ö –ø–æ–ª–∏—Ç–æ–ø–æ–≤ –≤ —Ñ–ª–∞–≥–µ –≤–æ–∑—å–º—ë–º –≤–µ—Ä—à–∏–Ω—É –≤—Ç–æ—Ä–æ–≥–æ, –Ω–µ –ª–µ–∂–∞—â—É—é –≤ –ø–µ—Ä–≤–æ–º,
–∫–æ—Ç–æ—Ä–∞—è —Å—Ç–∞–Ω–µ—Ç –∫–æ–Ω—Ü–æ–º –≤–µ–∫—Ç–æ—Ä–∞.

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é —Å –ø—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π –≤—Ö–æ–¥–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:
```kotlin title="innerVectorPerpendicularTo.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
    Polytope: PolytopicConstruction.Polytope<Point, Polytope, *>
> Polytope.innerVectorPerpendicularTo(face: Polytope): Vector {
    require(this.dimension > face.dimension && face in this.facesOfDimension(face.dimension))
    TODO()
}
```

–í–æ–∑—å–º—ë–º —Ñ–ª–∞–≥ –≥—Ä–∞–Ω–∏ —Å –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–º –ø–æ—Å–ª–µ –Ω–µ–≥–æ –¥–∞–Ω–Ω—ã–º –ø–æ–ª–∏—Ç–æ–ø–æ–º, —á—Ç–æ–±—ã –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Å—ë –æ–¥–Ω–∏–º —Ü–∏–∫–ª–æ–º –∏ –ø–æ–ª—É—á–∏—Ç—å –∏—Å–∫–æ–º—ã–π –±–∞–∑–∏—Å —Å—Ä–∞–∑—É.
```kotlin title="innerVectorPerpendicularTo.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
    Polytope: PolytopicConstruction.Polytope<Point, Polytope, *>
> Polytope.innerVectorPerpendicularTo(face: Polytope): Vector {
    require(this.dimension > face.dimension && face in this.facesOfDimension(face.dimension))
    val flagAndPolytope = KoneList.build {
        addAllFrom(face.anyFlag())
        add(this@innerVectorPerpendicularTo)
    }
    TODO()
}
```

–í–æ–∑—å–º—ë–º –Ω–∞—á–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É:
```kotlin title="innerVectorPerpendicularTo.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
    Polytope: PolytopicConstruction.Polytope<Point, Polytope, *>
> Polytope.innerVectorPerpendicularTo(face: Polytope): Vector {
    require(this.dimension > face.dimension && face in this.facesOfDimension(face.dimension))
    val flagAndPolytope = KoneList.build {
        addAllFrom(face.anyFlag())
        add(this@innerVectorPerpendicularTo)
    }
    val startPoint = flagAndPolytope[0u].vertices.single().position
    TODO()
}
```

–ü–æ—Å—Ç—Ä–æ–∏–º –±–∞–∑–∏—Å:
```kotlin title="innerVectorPerpendicularTo.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
    Polytope: PolytopicConstruction.Polytope<Point, Polytope, *>
> Polytope.innerVectorPerpendicularTo(face: Polytope): Vector {
    require(this.dimension > face.dimension && face in this.facesOfDimension(face.dimension))
    val flagAndPolytope = KoneList.build {
        addAllFrom(face.anyFlag())
        add(this@innerVectorPerpendicularTo)
    }
    val startPoint = flagAndPolytope[0u].vertices.single().position
    KoneList.build<Vector> {
        for (index in 0u ..< flagAndPolytope.lastIndex) {
            val innerPolytope = flagAndPolytope[index]
            val outerPolytope = flagAndPolytope[index + 1u]
            +(outerPolytope.vertices.firstThat { it !in innerPolytope.vertices }.position - startPoint)
        }
    }
    TODO()
}
```

–û—Å—Ç–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ—Ä—Ç–æ–≥–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å, –≤–∑—è—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–µ–∫—Ç–æ—Ä –∏ –≤–µ—Ä–Ω—É—Ç—å –µ–≥–æ:
```kotlin title="innerVectorPerpendicularTo.kt"
context(_: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
    Polytope: PolytopicConstruction.Polytope<Point, Polytope, *>
> Polytope.innerVectorPerpendicularTo(face: Polytope): Vector {
    require(this.dimension > face.dimension && face in this.facesOfDimension(face.dimension))
    val flagAndPolytope = KoneList.build {
        addAllFrom(face.anyFlag())
        add(this@innerVectorPerpendicularTo)
    }
    val startPoint = flagAndPolytope[0u].vertices.single().position
    return KoneList.build<Vector> {
        for (index in 0u ..< flagAndPolytope.lastIndex) {
            val innerPolytope = flagAndPolytope[index]
            val outerPolytope = flagAndPolytope[index + 1u]
            +(outerPolytope.vertices.firstThat { it !in innerPolytope.vertices }.position - startPoint)
        }
    }.orthogonalizeByGramSchmidt().last()
}
```

### –®–∞–≥: –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞, —Ç–æ—á–∫–∏ –≤–Ω–µ –µ–≥–æ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏ –∏ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–∏—Ç–æ–ø —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å, –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—É—é –≤–µ–∫—Ç–æ—Ä—É

–ü–æ—Å–∫–æ–ª—å–∫—É —Ç–æ—á–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–Ω–µ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏, –ø—Ä–æ–µ–∫—Ü–∏—è –≤—Å—è–∫–æ–π –≥—Ä–∞–Ω–∏ –±—É–¥–µ—Ç —Ç–∞–∫–æ–π –∂–µ –ø–æ —Ñ–æ—Ä–º–µ –≥—Ä–∞–Ω—å—é.
–¢–∞–∫ –∫–∞–∫ –Ω–∏–∫–∞–∫–∏–µ —Ç–æ—á–∫–∏ –Ω–µ –º–æ–≥—É—Ç —Å–ª–∏–ø–Ω—É—Ç—å—Å—è, —Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–æ—Å—Ç–æ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ç–∞–∫–æ–π –∂–µ –ø–æ–ª–∏—Ç–æ–ø —Å –Ω–æ–≤—ã–º–∏ –ø–æ–ª–æ–∂–µ–Ω–∏—è–º–∏ –≤–µ—Ä—à–∏–Ω.
–¢–∞–∫ –∫–∞–∫ –≤—Å—è–∫–∞—è –≥—Ä–∞–Ω—å –º–æ–∂–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–æ–ª–∏—Ç–æ–ø–∞—Ö,
—Ç–æ –Ω—É–∂–Ω–∞ –º–∞–ø–∞, –≤ –∫–æ—Ç–æ—Ä—É—é –∑–∞–Ω–æ—Å—è—Ç –Ω–æ–≤—ã–µ –ø—Ä–æ–µ–∫—Ü–∏–∏ –∏ –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –¥–æ—Å—Ç–∞—é—Ç –∏–º–µ—é—â–∏–µ—Å—è.

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    TODO()
}
```

–°–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –∏—Å–∫–æ–º–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è —É–∂–µ –≤ —Ä–µ–µ—Å—Ç—Ä–µ. –ò –µ—Å–ª–∏ –µ—Å—Ç—å, —Ç–æ –≤–µ—Ä–Ω—É—Ç—å –µ—ë.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    TODO()
}
```

–ó–∞—Ç–µ–º –æ—Ç—Ä–∞–±–æ—Ç–∞–µ–º –Ω–æ–ª—å-–º–µ—Ä–Ω—ã–π —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –æ–¥–Ω—É –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—É—é –≤–µ—Ä—à–∏–Ω—É.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    if (area.dimension == 0u)
        return target.addVertex(
            area.vertices.single().position.let {
                val vector = (it - point)
                point + vector / (vector dot normal)
            }
        ).asPolytope().also { polytopesRegistry[0u][area] = it }

    TODO()
}
```

–•–æ—Ä–æ—à–æ, –∑–Ω–∞—á–∏—Ç, —Ç–µ–ø–µ—Ä—å —É –Ω–∞—Å —Å–ª—É—á–∞–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ —Ö–æ—Ç—è –±—ã 1. –¢–æ–≥–¥–∞ —Å–Ω–∞—á–∞–ª–∞ —Å–ø—Ä–æ–µ—Ü–∏—Ä—É–µ–º –≤—Å–µ —Ñ–∞—Å–µ—Ç—ã.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    if (area.dimension == 0u)
        return target.addVertex(
            area.vertices.single().position.let {
                val vector = (it - point)
                point + vector / (vector dot normal)
            }
        ).asPolytope().also { polytopesRegistry[0u][area] = it }

    val newFacets = area.facesOfDimension(area.dimension - 1u).map { facet ->
        projectThroughPointInGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )
    }

    TODO()
}
```

–¢–µ–ø–µ—Ä—å —Å–æ–±–µ—Ä—ë–º –¥–ª—è –ø—Ä–æ–µ–∫—Ü–∏–∏ –Ω–∞—à–µ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞ –≤—Å–µ –µ–≥–æ –≥—Ä–∞–Ω–∏ –∫–∞–∂–¥–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    if (area.dimension == 0u)
        return target.addVertex(
            area.vertices.single().position.let {
                val vector = (it - point)
                point + vector / (vector dot normal)
            }
        ).asPolytope().also { polytopesRegistry[0u][area] = it }

    val newFacets = area.facesOfDimension(area.dimension - 1u).map { facet ->
        projectThroughPointInGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )
    }

    val newFaces = KoneList(area.dimension) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    for (facet in newFacets) {
        for (dim in 0u ..< facet.dimension) newFaces[dim].addAllFrom(facet.facesOfDimension(dim))
        newFaces[facet.dimension].add(facet)
    }

    TODO()
}
```

–¢–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –æ—Å—Ç–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–µ–∫—Ü–∏—é –ø–æ–ª–∏—Ç–æ–ø–∞, —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –µ—ë –≤ —Ä–µ–µ—Å—Ç—Ä –∏ –≤–µ—Ä–Ω—É—Ç—å.
```kotlin title="projectThroughPointInGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    if (area.dimension == 0u)
        return target.addVertex(
            area.vertices.single().position.let {
                val vector = (it - point)
                point + vector / (vector dot normal)
            }
        ).asPolytope().also { polytopesRegistry[0u][area] = it }

    val newFacets = area.facesOfDimension(area.dimension - 1u).map { facet ->
        projectThroughPointInGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )
    }

    val newFaces = KoneList(area.dimension) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    for (facet in newFacets) {
        for (dim in 0u ..< facet.dimension) newFaces[dim].addAllFrom(facet.facesOfDimension(dim))
        newFaces[facet.dimension].add(facet)
    }

    return target.addPolytope(
        dimension = area.dimension,
        vertices = newFaces[0u].mapTo(
            KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Vertex<Point>>(
                elementEquality = Equality.absoluteFor(),
                elementHashing = Hashing.defaultFor(),
            )
        ) { it.vertices.single() },
        faces = newFaces,
    ).also { polytopesRegistry[area.dimension][area] = it }
}
```

### –®–∞–≥: –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞, —Ç–æ—á–∫–∏ –≤ –µ–≥–æ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ –∏ –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–∏—Ç–æ–ø —á–µ—Ä–µ–∑ —Ç–æ—á–∫—É –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å, –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω—É—é –≤–µ–∫—Ç–æ—Ä—É

–¢–µ–ø–µ—Ä—å —Å—Ç–æ–∏—Ç –∑–∞–¥–∞—á–∞ –ø–æ—Å–ª–æ–∂–Ω–µ–µ.
–í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –ø—Ä–æ–µ–∫—Ü–∏–∏ —Ñ–∞—Å–µ—Ç –Ω–∞–∫–ª–∞–¥—ã–≤–∞—é—Ç—Å—è, –∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ñ–∞—Å–µ—Ç—ã –¥–∞–∂–µ –ø—Ä–æ–µ—Ü–∏—Ä—É—é—Ç—Å—è –≤ –≥—Ä–∞–Ω—å –Ω–∞ 1 –º–µ–Ω—å—à–µ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏.
–ë—É–¥–µ–º –≥–æ–≤–æ—Ä–∏—Ç—å, —á—Ç–æ —Ñ–∞—Å–µ—Ç–∞ *–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–∞*,
–µ—Å–ª–∏ —Ç–æ—á–∫–∞ –ø—Ä–æ–µ–∫—Ü–∏–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å—Ç—Ä–æ–≥–æ –ø–æ —Ç—É –∂–µ —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç —Ñ–∞—Å–µ—Ç—ã, —á—Ç–æ –∏ –≤–µ—Å—å –æ—Å—Ç–∞–≤—à–∏–π—Å—è –ø–æ–ª–∏—Ç–æ–ø,
*–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–∞*, –µ—Å–ª–∏ –ø–æ —Å—Ç—Ä–æ–≥–æ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é,
–∏ *–Ω—É–ª–µ–≤–∞—è*, –µ—Å–ª–∏ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ —Ñ–∞—Å–µ—Ç—ã.
–ß—Ç–æ–±—ã –ø–æ—Å—Ç—Ä–æ–∏—Ç—å —Ç–æ–ª—å–∫–æ –≤–Ω–µ—à–Ω–∏–π –∫–æ–Ω—Ç—É—Ä –ø—Ä–æ–µ–∫—Ü–∏–∏, –Ω–∞–π–¥—ë–º –≤—Å–µ —Ö—Ä–µ–±—Ç—ã –Ω–∞—à–µ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞,
–∫–æ—Ç–æ—Ä—ã–µ —è–≤–ª—è—é—Ç—Å—è –æ–±—â–µ–π –≥—Ä–∞–Ω–∏—Ü–µ–π –æ–¥–Ω–æ–π –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π –∏ –æ–¥–Ω–æ–π –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π —Ñ–∞—Å–µ—Ç,
–∞ —Ç–∞–∫–∂–µ –≤—Å–µ –Ω—É–ª–µ–≤—ã–µ —Ñ–∞—Å–µ—Ç—ã.
–¢–æ–≥–¥–∞ —Å–ø—Ä–æ–µ—Ü–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∏—Ö –Ω–∞ –ø–ª–æ—Å–∫–æ—Å—Ç—å.
–í —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ —Ñ–∞—Å–µ—Ç–∞–º–∏ –ø—Ä–æ–µ–∫—Ü–∏–∏ –±—É–¥—É—Ç –ø—Ä–æ–µ–∫—Ü–∏–∏ —ç—Ç–∏—Ö —Ö—Ä–µ–±—Ç–æ–≤ –∏ –Ω—É–ª–µ–≤—ã—Ö —Ñ–∞—Å–µ—Ç.
–¢–∞–∫–∂–µ –Ω–µ—Å–ª–æ–∂–Ω–æ –ø–æ–Ω—è—Ç—å, —á—Ç–æ –≤—Å—è–∫–∞—è —Ñ–∞—Å–µ—Ç–∞ –ø—Ä–æ–µ–∫—Ü–∏–∏ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –∏–∑ —Ä–æ–≤–Ω–æ –æ–¥–Ω–æ–≥–æ —Ö—Ä–µ–±—Ç–∞ –∏–ª–∏ –Ω—É–ª–µ–≤–æ–π —Ñ–∞—Å–µ—Ç—ã.
–¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –º–æ–∂–Ω–æ –∑–∞–≤–µ—Å—Ç–∏ —Ä–µ–µ—Å—Ç—Ä –ø—Ä–æ–µ–∫—Ü–∏–π, –≥–¥–µ –ø—Ä–æ–µ–∫—Ü–∏–µ–π –ø–æ–ª–∏—Ç–æ–ø–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–∏—Ç–æ–ø –Ω–∞ 1 –º–µ–Ω—å—à–µ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏.

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    TODO()
}
```

–°–Ω–∞—á–∞–ª–∞ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –∏—Å–∫–æ–º–∞—è –ø—Ä–æ–µ–∫—Ü–∏—è —É–∂–µ –≤ —Ä–µ–µ—Å—Ç—Ä–µ. –ò –µ—Å–ª–∏ –µ—Å—Ç—å, —Ç–æ –≤–µ—Ä–Ω—É—Ç—å –µ—ë.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    TODO()
}
```

–î–∞–ª—å—à–µ –æ–±—Ä–∞–±–æ—Ç–∞–µ–º 0- –∏ 1-–º–µ—Ä–Ω—ã–π —Å–ª—É—á–∞–∏.
–í 0-–º–µ—Ä–Ω–æ–º —Å–ª—É—á–∞–µ –∑–∞–¥–∞—á–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞, –ø–æ—ç—Ç–æ–º—É –Ω–∞–¥–æ –≤—ã–¥–∞—Ç—å –æ—à–∏–±–∫—É.
–í 1-–º–µ—Ä–Ω–æ–º —Å–ª—É—á–∞–µ –Ω–∞–¥–æ –ø—Ä–æ—Å—Ç–æ –≤–∑—è—Ç—å –≤–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω–æ–π –ø—Ä—è–º–æ–π –∏ —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    TODO()
}
```

–î–∞–ª—å—à–µ —Å–æ–±–µ—Ä—ë–º –≤—Å–µ —Ñ–∞—Å–µ—Ç—ã –ø–æ–ª–∏—Ç–æ–ø–∞ –∏ –ø—Ä–∏—Å–≤–æ–∏–º –∏–º –∑–Ω–∞–∫–∏.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    TODO()
}
```

–ü–æ—Å–ª–µ —á–µ–≥–æ –ø—Ä–æ—Å—Ç–æ –≤—ã–¥–µ–ª–∏–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞—Å–µ—Ç—ã –∏ –Ω—É–ª–µ–≤—ã–µ —Ñ–∞—Å–µ—Ç—ã.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    TODO()
}
```

–¢–µ–ø–µ—Ä—å –Ω–∞—á–Ω—ë–º —Å–æ–±–∏—Ä–∞—Ç—å –≥—Ä–∞–Ω–∏ –ø–æ–ª–∏—Ç–æ–ø–∞-–ø—Ä–æ–µ–∫—Ü–∏–∏ –∏ –∏—Å–∫–æ–º—ã–µ —Ö—Ä–µ–±—Ç—ã –¥–ª—è –ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞–Ω–∏—è.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    val faces = KoneList(area.dimension - 1u) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementReification = Reification.defaultFor(),
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    val ridgesToProject = KoneMutableSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
        elementEquality = Equality.absoluteFor(),
        elementHashing = Hashing.defaultFor(),
    )

    TODO()
}
```

–í—Å–ø–æ–º–Ω–∏–º, —á—Ç–æ –∏—Å–∫–æ–º—ã–µ —Ö—Ä–µ–±—Ç—ã &mdash; —Ö—Ä–µ–±—Ç—ã, —Å–æ–µ–¥–∏–Ω—è—é—â–∏–µ –¥–≤–µ —Ñ–∞—Å–µ—Ç—ã, –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—É—é –∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—É—é.
–¢.–µ. –≠—Ç–æ —Ö—Ä–µ–±—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è —É —Ä–æ–≤–Ω–æ –æ–¥–Ω–æ–π –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π —Ñ–∞—Å–µ—Ç—ã
(–∞ –≤—Å—Ç—Ä–µ—á–∞—Ç—å—Å—è –æ–Ω–∏ –º–æ–≥—É—Ç –Ω–µ –±–æ–ª–µ–µ, —á–µ–º —É –¥–≤—É—Ö —Ñ–∞—Å–µ—Ç),
–Ω–æ –Ω–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è —É –Ω—É–ª–µ–≤—ã—Ö —Ñ–∞—Å–µ—Ç.
–¢–æ–≥–¥–∞ –ø–µ—Ä–µ–±–µ—Ä—ë–º –≤—Å–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞—Å–µ—Ç—ã –∏ –Ω–∞–π–¥—ë–º —Ö—Ä–µ–±—Ç—ã –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è —É –Ω–∏—Ö –≤—Å–µ—Ö –≤–º–µ—Å—Ç–µ –≤–∑—è—Ç—ã—Ö –ø–æ –æ–¥–Ω–æ–º—É —Ä–∞–∑—É.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    val faces = KoneList(area.dimension - 1u) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementReification = Reification.defaultFor(),
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    val ridgesToProject = KoneMutableSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
        elementEquality = Equality.absoluteFor(),
        elementHashing = Hashing.defaultFor(),
    )

    for (facet in positiveFacets) for (ridge in facet.facesOfDimension(facet.dimension - 1u))
        if (ridge in ridgesToProject) ridgesToProject.remove(ridge)
        else ridgesToProject.add(ridge)

    TODO()
}
```

–¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–±–µ—Ä—ë–º –Ω—É–ª–µ–≤—ã–µ —Ñ–∞—Å–µ—Ç—ã –∏ —Å–¥–µ–ª–∞–µ–º –¥–≤–µ –≤–µ—â–∏:
1. —Å–ø—Ä–æ–µ—Ü–∏—Ä—É–µ–º –∏—Ö, –¥–æ–±–∞–≤–ª—è—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤–æ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≥—Ä–∞–Ω–µ–π,
2. –≤—ã–∫–∏–Ω–µ–º –∏—Ö —Ñ–∞—Å–µ—Ç—ã –∏–∑ —Ö—Ä–µ–±—Ç–æ–≤ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–µ.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    val faces = KoneList(area.dimension - 1u) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementReification = Reification.defaultFor(),
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    val ridgesToProject = KoneMutableSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
        elementEquality = Equality.absoluteFor(),
        elementHashing = Hashing.defaultFor(),
    )

    for (facet in positiveFacets) for (ridge in facet.facesOfDimension(facet.dimension - 1u))
        if (ridge in ridgesToProject) ridgesToProject.remove(ridge)
        else ridgesToProject.add(ridge)

    for (facet in zeroFacets) {
        ridgesToProject.removeAllFrom(facet.facesOfDimension(facet.dimension - 1u))

        val projection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )

        for (dim in 0u ..< projection.dimension) faces[dim].addAllFrom(projection.facesOfDimension(dim))
        faces[projection.dimension].add(projection)
    }

    TODO()
}
```

–¢–µ–ø–µ—Ä—å, –Ω–∞–∫–æ–Ω–µ—Ü, —Å–ø—Ä–æ–µ—Ü–∏—Ä—É–µ–º —Ö—Ä–µ–±—Ç—ã.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    val faces = KoneList(area.dimension - 1u) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementReification = Reification.defaultFor(),
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    val ridgesToProject = KoneMutableSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
        elementEquality = Equality.absoluteFor(),
        elementHashing = Hashing.defaultFor(),
    )

    for (facet in positiveFacets) for (ridge in facet.facesOfDimension(facet.dimension - 1u))
        if (ridge in ridgesToProject) ridgesToProject.remove(ridge)
        else ridgesToProject.add(ridge)

    for (facet in zeroFacets) {
        ridgesToProject.removeAllFrom(facet.facesOfDimension(facet.dimension - 1u))

        val projection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )

        for (dim in 0u ..< projection.dimension) faces[dim].addAllFrom(projection.facesOfDimension(dim))
        faces[projection.dimension].add(projection)
    }

    for (ridge in ridgesToProject) {
        val projection = projectThroughPointInGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = ridge,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )

        for (dim in 0u ..< projection.dimension) faces[dim].addAllFrom(projection.facesOfDimension(dim))
        faces[projection.dimension].add(projection)
    }

    TODO()
}
```

–¢–µ–ø–µ—Ä—å –æ—Å—Ç–∞–ª–æ—Å—å —Ç–æ–ª—å–∫–æ —Å–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ü–∏—é –≤—Å–µ–≥–æ –ø–æ–ª–∏—Ç–æ–ø–∞, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –µ—ë –∏ –≤–µ—Ä–Ω—É—Ç—å.
```kotlin title="projectThroughPointInNonGeneralPositionOntoNormalPlane.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
fun <
    Number,
    Vector,
    Point,
> projectThroughPointInNonGeneralPositionOntoNormalPlane(
    point: Point,
    normal: Vector,
    area: AbstractPolytopicConstruction.Polytope<Point>,
    polytopesRegistry: KoneList<KoneMutableMap<AbstractPolytopicConstruction.Polytope<Point>, AbstractPolytopicConstruction.Polytope<Point>>>,
    target: AbstractPolytopicConstruction<Point>,
): AbstractPolytopicConstruction.Polytope<Point> {
    polytopesRegistry[area.dimension].getOrNull(area)?.let { return it }

    when (area.dimension) {
        0u -> error("Cannot have normal vector in 0-dimensional non-general position")
        1u -> {
            val vector = area.vertices.first().position - point
            return target.addVertex(point + vector / (vector dot normal)).asPolytope().also { polytopesRegistry[1u][area] = it }
        }
    }

    data class FacetWithSign(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val sign: Sign,
    )

    val facetsSigns = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        FacetWithSign(facet, ((point - start) dot facetNormal).sign())
    }

    val positiveFacets = facetsSigns.filter { it.sign.isPositive() }.map { it.facet }
    val zeroFacets = facetsSigns.filter { it.sign.isZero() }.map { it.facet }

    val faces = KoneList(area.dimension - 1u) {
        KoneMutableReifiedSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
            elementReification = Reification.defaultFor(),
            elementEquality = Equality.absoluteFor(),
            elementHashing = Hashing.defaultFor(),
        )
    }

    val ridgesToProject = KoneMutableSet.of<AbstractPolytopicConstruction.Polytope<Point>>(
        elementEquality = Equality.absoluteFor(),
        elementHashing = Hashing.defaultFor(),
    )

    for (facet in positiveFacets) for (ridge in facet.facesOfDimension(facet.dimension - 1u))
        if (ridge in ridgesToProject) ridgesToProject.remove(ridge)
        else ridgesToProject.add(ridge)

    for (facet in zeroFacets) {
        ridgesToProject.removeAllFrom(facet.facesOfDimension(facet.dimension - 1u))

        val projection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = facet,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )

        for (dim in 0u ..< projection.dimension) faces[dim].addAllFrom(projection.facesOfDimension(dim))
        faces[projection.dimension].add(projection)
    }

    for (ridge in ridgesToProject) {
        val projection = projectThroughPointInGeneralPositionOntoNormalPlane(
            point = point,
            normal = normal,
            area = ridge,
            polytopesRegistry = polytopesRegistry,
            target = target,
        )

        for (dim in 0u ..< projection.dimension) faces[dim].addAllFrom(projection.facesOfDimension(dim))
        faces[projection.dimension].add(projection)
    }

    return target.addPolytope(
        dimension = area.dimension - 1u,
        vertices = faces.first().mapTo(
            KoneMutableReifiedSet.of(
                elementReification = Reification.defaultFor(),
                elementEquality = Equality.absoluteFor(),
                elementHashing = Hashing.defaultFor(),
            )
        ) { it.vertices.single() },
        faces = faces,
    ).also { polytopesRegistry[area.dimension][area] = it }
}
```

### –§–∏–Ω–∞–ª—å–Ω—ã–π —à–∞–≥

–¢–µ–ø–µ—Ä—å –Ω–∞–º –æ—Å—Ç–∞–ª–æ—Å—å –Ω–∞—É—á–∏—Ç—å—Å—è –ø—Ä–æ–≤–µ—Ä—è—Ç—å –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º–æ—Å—Ç—å –ø–æ–ª–∏—Ç–æ–ø–∞ –∏ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–∏.
–ö–∞–∫ —É–∂–µ –≥–æ–≤–æ—Ä–∏–ª–æ—Å—å –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –º—ã –±—É–¥–µ–º —ç—Ç–æ –¥–µ–ª–∞—Ç—å –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ,
—É–º–µ–Ω—å—à–∞—è —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤—Å–µ–æ–±—ä–µ–º–ª—é—â–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –Ω–∞ 1,
–ø–æ–∫–∞ –Ω–µ –Ω–∞—Ç–∫–Ω—ë–º—Å—è –Ω–∞ —è–≤–Ω—ã–π –æ—Ç–≤–µ—Ç.
(–ó–∞–æ–¥–Ω–æ –±—É–¥–µ–º –¥–µ–ª–∞—Ç—å —ç—Ç–æ —Å –ø–æ–º–æ—â—å—é —Ö–≤–æ—Å—Ç–æ–≤–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏.)

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    TODO()
}
```

–ü–µ—Ä–≤—ã–º –¥–µ–ª–æ–º –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –∞—Ñ—Ñ–∏–Ω–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ –Ω–µ–ø—É—Å—Ç–∞—è.
–ï—Å–ª–∏ –æ–Ω–æ –ø—É—Å—Ç–æ–µ, —Ç–æ –º–æ–∂–Ω–æ —Å—Ä–∞–∑—É –≤–µ—Ä–Ω—É—Ç—å `false`.
–ò–Ω–∞—á–µ –º–æ–∂–Ω–æ –≤—ã–¥–µ–ª–∏—Ç—å –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –∏–∑ —Å–ø–∏—Å–∫–∞ –∏ –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ.
–ü—Ä–∏ —ç—Ç–æ–º –µ—Å–ª–∏ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –≤—ã–ø—É–∫–ª–æ–π –æ–±–æ–ª–æ—á–∫–∏ (–∏ –≤—Å–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞) —Ä–∞–≤–Ω–∞ 0, —Ç–æ –æ—á–µ–≤–∏–¥–µ–Ω –æ—Ç–≤–µ—Ç `true`.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    if (solutions.isEmpty()) return false

    val primarySolution = solutions.first()
    val otherSolutions = solutions.drop(1u)

    if (area.dimension == 0u) return true

    TODO()
}
```

–¢–µ–ø–µ—Ä—å –¥–ª—è –∫–∞–∂–¥–æ–π —Ñ–∞—Å–µ—Ç—ã –Ω–∞–π–¥—ë–º –Ω–æ—Ä–º–∞–ª—å, –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—É—é –≤–Ω—É—Ç—Ä—å –ø–æ–ª–∏—Ç–æ–ø–∞,
–∏ –ø—Ä–æ–≤–µ—Ä–∏–º, –ª–µ–∂–∏—Ç –ª–∏ –Ω–∞—à–∞ —Ç–æ—á–∫–∞ —Å—Ç—Ä–æ–≥–æ –ø–æ —Ç—É –∂–µ —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç —ç—Ç–æ–π —Ñ–∞—Å–µ—Ç—ã, —á—Ç–æ –∏ –æ—Å—Ç–∞–≤—à–∏–π—Å—è –ø–æ–ª–∏—Ç–æ–ø.
–ü—Ä–∏ —ç—Ç–æ–º –µ—Å–ª–∏ –º—ã –Ω–∞–π–¥—ë–º —Ñ–∞—Å–µ—Ç—É, –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ—Ç–æ—Ä–æ–π —Ç–æ—á–∫–∞ –ª–µ–∂–∏—Ç —Å—Ç—Ä–æ–≥–æ –ø–æ –æ–±—Ä–∞—Ç–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É,
—Ç–æ –º–æ–∂–Ω–æ –ø—Ä–µ—Ä–≤–∞—Ç—å –ø—Ä–æ—Ü–µ—Å—Å, —Ç–∞–∫ –∫–∞–∫ –º—ã –Ω–∞—à–ª–∏ —Ä–∞–∑–¥–µ–ª—è—é—â—É—é –ø–ª–æ—Å–∫–æ—Å—Ç—å,
—Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –≤—Å—ë –Ω–∞ –Ω–µ—ë –∏ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–ø—É—Å—Ç–∏—Ç—å—Å—è –¥–∞–ª—å—à–µ.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    if (solutions.isEmpty()) return false

    val primarySolution = solutions.first()
    val otherSolutions = solutions.drop(1u)

    if (area.dimension == 0u) return true

    data class FacetNormalAndIsStrictlyInside(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val normal: Vector,
        val isStrictlyInside: Boolean,
    )

    val facetNormalAndIsStrictlyInsides = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        val sign = ((primarySolution - start) dot facetNormal).sign()

        if (sign.isNegative()) {
            val nonParallelSolution = otherSolutions.firstThatOrNull { ((it - primarySolution) dot facetNormal).isNotZero() } ?: return false
            val otherSolutionProjections = otherSolutions.map {
                val vector = it - primarySolution
                val vectorDotNormal = vector dot facetNormal
                if (vectorDotNormal.isNotZero()) primarySolution + vector / (vector dot facetNormal)
                else {
                    val newVector = vector + (nonParallelSolution - primarySolution)
                    primarySolution + newVector / (newVector dot facetNormal)
                }
            }
            val areaProjection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
                point = primarySolution,
                normal = facetNormal,
                area = area,
                polytopesRegistry = KoneList(area.dimension + 1u) {
                    KoneMutableMap.of(
                        keyEquality = Equality.absoluteFor(),
                        keyHashing = Hashing.defaultFor(),
                    )
                },
                target = AbstractPolytopicConstruction(facet.dimension),
            )

            return checkIntersectionOfAreaAndSolutions(
                area = areaProjection,
                solutions = otherSolutionProjections,
            )
        }

        FacetNormalAndIsStrictlyInside(facet, facetNormal, sign.isPositive())
    }

    TODO()
}
```

–ï—Å–ª–∏ –º—ã —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –Ω–µ —Å–ø—É—Å—Ç–∏–ª–∏—Å—å, –∞ —Å–æ–±—Ä–∞–ª–∏ –≤—Å—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ —Ñ–∞—Å–µ—Ç–∞–º,
—Ç–æ –º—ã –¥–ª—è –∫–∞–∂–¥–æ–π —Ñ–∞—Å–µ—Ç—ã –Ω–∞—Ö–æ–¥–∏–º—Å—è –Ω–µ—Å—Ç—Ä–æ–≥–æ –ø–æ —Ç—É –∂–µ —Å—Ç–æ—Ä–æ–Ω—É, —á—Ç–æ –æ—Å—Ç–∞–ª—å–Ω–æ–π –ø–æ–ª–∏—Ç–æ–ø.
–¢–æ–≥–¥–∞ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–≤–µ –ø—Ä–æ—Å—Ç—ã—Ö –ø—Ä–æ–≤–µ—Ä–∫–∏:
1. –ï—Å–ª–∏ —Ç–æ—á–∫–∞ —Å—Ç—Ä–æ–≥–æ –≤–Ω—É—Ç—Ä–∏ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–∞–∂–¥–æ–π —Ñ–∞—Å–µ—Ç—ã, —Ç–æ –æ–Ω–∞ —Å—Ç—Ä–æ–≥–æ –≤–Ω—É—Ç—Ä–∏ –ø–æ–ª–∏—Ç–æ–ø–∞, –∞, –∑–Ω–∞—á–∏—Ç, –º–æ–∂–Ω–æ –≤—ã–≤–µ—Å—Ç–∏ `true`.
2. –ò–Ω–∞—á–µ –µ—Å–ª–∏ –±–æ–ª—å—à–µ —Ç–æ—á–µ–∫ –≤ –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ –Ω–µ—Ç, —Ç–æ –≤—Å—è –∞—Ñ—Ñ–∏–Ω–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ &mdash; —ç—Ç–æ —Ç–æ—á–∫–∞ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –ø–æ–ª–∏—Ç–æ–ø–∞, —á—Ç–æ –Ω–∞–º –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    if (solutions.isEmpty()) return false

    val primarySolution = solutions.first()
    val otherSolutions = solutions.drop(1u)

    if (area.dimension == 0u) return true

    data class FacetNormalAndIsStrictlyInside(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val normal: Vector,
        val isStrictlyInside: Boolean,
    )

    val facetNormalAndIsStrictlyInsides = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        val sign = ((primarySolution - start) dot facetNormal).sign()

        if (sign.isNegative()) {
            val nonParallelSolution = otherSolutions.firstThatOrNull { ((it - primarySolution) dot facetNormal).isNotZero() } ?: return false
            val otherSolutionProjections = otherSolutions.map {
                val vector = it - primarySolution
                val vectorDotNormal = vector dot facetNormal
                if (vectorDotNormal.isNotZero()) primarySolution + vector / (vector dot facetNormal)
                else {
                    val newVector = vector + (nonParallelSolution - primarySolution)
                    primarySolution + newVector / (newVector dot facetNormal)
                }
            }
            val areaProjection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
                point = primarySolution,
                normal = facetNormal,
                area = area,
                polytopesRegistry = KoneList(area.dimension + 1u) {
                    KoneMutableMap.of(
                        keyEquality = Equality.absoluteFor(),
                        keyHashing = Hashing.defaultFor(),
                    )
                },
                target = AbstractPolytopicConstruction(facet.dimension),
            )

            return checkIntersectionOfAreaAndSolutions(
                area = areaProjection,
                solutions = otherSolutionProjections,
            )
        }

        FacetNormalAndIsStrictlyInside(facet, facetNormal, sign.isPositive())
    }

    if (facetNormalAndIsStrictlyInsides.all { it.isStrictlyInside }) return true
    if (otherSolutions.isEmpty()) return false

    TODO()
}
```

–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –≤—Å—ë –µ—â—ë –Ω–∏—á–µ–≥–æ –Ω–µ –≤–µ—Ä–Ω—É–ª–∞, —Ç–æ –Ω–∞–º –Ω–µ –ø–æ–≤–µ–∑–ª–æ –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –Ω–∞ –≥—Ä–∞–Ω–∏—Ü–µ –ø–æ–ª–∏—Ç–æ–ø–∞, –∏–º–µ—è –Ω–µ 0-–º–µ—Ä–Ω—É—é –∞—Ñ—Ñ–∏–Ω–Ω—É—é –æ–±–æ–ª–æ—á–∫—É.
–ó–Ω–∞—á–∏—Ç –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –Ω–æ–≤—É—é —Ç–æ—á–∫—É, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Å—Ç—Ä–æ–≥–æ –≤–Ω–µ –ø–æ–ª–∏—Ç–æ–ø–∞.
–î–ª—è —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –Ω–∞–π—Ç–∏ –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å –≤–µ–∫—Ç–æ—Ä –≤ –Ω–∞—à–µ–π –∞—Ñ—Ñ–∏–Ω–Ω–æ–π –æ–±–æ–ª–æ—á–∫–µ –∏ —Ñ–∞—Å–µ—Ç—É, –≤ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω –Ω–µ –±—É–¥–µ—Ç –ª–µ–∂–∞—Ç—å.
–¢–æ–≥–¥–∞ –Ω–∞ —ç—Ç–æ–π –ø—Ä—è–º–æ–π –±—É–¥–µ—Ç —Ç–æ—á–∫–∞, –ª–µ–∂–∞—â–∞—è –ø–æ –¥—Ä—É–≥—É—é —Å—Ç–æ—Ä–æ–Ω—É –æ—Ç –ø–æ–ª–∏—Ç–æ–ø–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —ç—Ç–æ–π —Ñ–∞—Å–µ—Ç—ã.
–ü–æ–¥–±–µ—Ä—ë–º —Ç–∞–∫—É—é —Ñ–∞—Å–µ—Ç—É –∏ —Ç–æ—á–∫—É –≤–Ω–µ –ø–æ–ª–∏—Ç–æ–ø–∞.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    if (solutions.isEmpty()) return false

    val primarySolution = solutions.first()
    val otherSolutions = solutions.drop(1u)

    if (area.dimension == 0u) return true

    data class FacetNormalAndIsStrictlyInside(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val normal: Vector,
        val isStrictlyInside: Boolean,
    )

    val facetNormalAndIsStrictlyInsides = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        val sign = ((primarySolution - start) dot facetNormal).sign()

        if (sign.isNegative()) {
            val nonParallelSolution = otherSolutions.firstThatOrNull { ((it - primarySolution) dot facetNormal).isNotZero() } ?: return false
            val otherSolutionProjections = otherSolutions.map {
                val vector = it - primarySolution
                val vectorDotNormal = vector dot facetNormal
                if (vectorDotNormal.isNotZero()) primarySolution + vector / (vector dot facetNormal)
                else {
                    val newVector = vector + (nonParallelSolution - primarySolution)
                    primarySolution + newVector / (newVector dot facetNormal)
                }
            }
            val areaProjection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
                point = primarySolution,
                normal = facetNormal,
                area = area,
                polytopesRegistry = KoneList(area.dimension + 1u) {
                    KoneMutableMap.of(
                        keyEquality = Equality.absoluteFor(),
                        keyHashing = Hashing.defaultFor(),
                    )
                },
                target = AbstractPolytopicConstruction(facet.dimension),
            )

            return checkIntersectionOfAreaAndSolutions(
                area = areaProjection,
                solutions = otherSolutionProjections,
            )
        }

        FacetNormalAndIsStrictlyInside(facet, facetNormal, sign.isPositive())
    }

    if (facetNormalAndIsStrictlyInsides.all { it.isStrictlyInside }) return true
    if (otherSolutions.isEmpty()) return false

    val shiftVector = otherSolutions.first() - primarySolution

    val firstFacetNormalAndIsStrictlyInside = facetNormalAndIsStrictlyInsides.firstThat { (it.normal dot shiftVector).isNotZero() }
    val normal = firstFacetNormalAndIsStrictlyInside.normal
    val start = firstFacetNormalAndIsStrictlyInside.facet.vertices.first().position
    val newPrimarySolution = primarySolution + shiftVector * (((start - primarySolution) dot normal) / (shiftVector dot normal) - (shiftVector dot normal))

    TODO()
}
```

–¢–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –∏ –æ—Å—Ç–∞–ª–æ—Å—å –≤—Å—ë —Å–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é.
```kotlin title="checkIntersectionOfAreaAndSolutions.kt"
context(field: Field<Number>, _: Order<Number>, _: EuclideanSpaceOverField<Number, Vector, Point>)
tailrec fun <
    Number,
    Vector,
    Point,
> checkIntersectionOfAreaAndSolutions(
    area: AbstractPolytopicConstruction.Polytope<Point>,
    solutions: KoneList<Point>,
): Boolean {
    if (solutions.isEmpty()) return false

    val primarySolution = solutions.first()
    val otherSolutions = solutions.drop(1u)

    if (area.dimension == 0u) return true

    data class FacetNormalAndIsStrictlyInside(
        val facet: AbstractPolytopicConstruction.Polytope<Point>,
        val normal: Vector,
        val isStrictlyInside: Boolean,
    )

    val facetNormalAndIsStrictlyInsides = area.facesOfDimension(area.dimension - 1u).map { facet ->
        val start = facet.vertices.first().position
        val facetNormal = area.innerVectorPerpendicularTo(facet)

        val sign = ((primarySolution - start) dot facetNormal).sign()

        if (sign.isNegative()) {
            val nonParallelSolution = otherSolutions.firstThatOrNull { ((it - primarySolution) dot facetNormal).isNotZero() } ?: return false
            val otherSolutionProjections = otherSolutions.map {
                val vector = it - primarySolution
                val vectorDotNormal = vector dot facetNormal
                if (vectorDotNormal.isNotZero()) primarySolution + vector / (vector dot facetNormal)
                else {
                    val newVector = vector + (nonParallelSolution - primarySolution)
                    primarySolution + newVector / (newVector dot facetNormal)
                }
            }
            val areaProjection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
                point = primarySolution,
                normal = facetNormal,
                area = area,
                polytopesRegistry = KoneList(area.dimension + 1u) {
                    KoneMutableMap.of(
                        keyEquality = Equality.absoluteFor(),
                        keyHashing = Hashing.defaultFor(),
                    )
                },
                target = AbstractPolytopicConstruction(facet.dimension),
            )

            return checkIntersectionOfAreaAndSolutions(
                area = areaProjection,
                solutions = otherSolutionProjections,
            )
        }

        FacetNormalAndIsStrictlyInside(facet, facetNormal, sign.isPositive())
    }

    if (facetNormalAndIsStrictlyInsides.all { it.isStrictlyInside }) return true
    if (otherSolutions.isEmpty()) return false

    val shiftVector = otherSolutions.first() - primarySolution

    val firstFacetNormalAndIsStrictlyInside = facetNormalAndIsStrictlyInsides.firstThat { (it.normal dot shiftVector).isNotZero() }
    val normal = firstFacetNormalAndIsStrictlyInside.normal
    val start = firstFacetNormalAndIsStrictlyInside.facet.vertices.first().position
    val newPrimarySolution = primarySolution + shiftVector * (((start - primarySolution) dot normal) / (shiftVector dot normal) - (shiftVector dot normal))

    val areaProjection = projectThroughPointInNonGeneralPositionOntoNormalPlane(
        point = newPrimarySolution,
        normal = normal,
        area = area,
        polytopesRegistry = KoneList(area.dimension + 1u) {
            KoneMutableMap.of(
                keyEquality = Equality.absoluteFor(),
                keyHashing = Hashing.defaultFor(),
            )
        },
        target = AbstractPolytopicConstruction(area.dimension - 1u),
    )
    val otherSolutionProjections = otherSolutions.map {
        val vector = it - newPrimarySolution
        newPrimarySolution + (vector / (vector dot normal))
    }

    return checkIntersectionOfAreaAndSolutions(
        area = areaProjection,
        solutions = otherSolutionProjections,
    )
}
```

## –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º –ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π

–ü–æ—Å–ª–µ —Ç–æ–≥–æ –∫–∞–∫ –º—ã –ø–æ–ª—É—á–∏–ª–∏ –≤—Å–µ —Å–∏—Å—Ç–µ–º—ã –ª–∏–Ω–µ–π–Ω—ã—Ö —É—Ä–∞–≤–Ω–µ–Ω–∏–π,
–Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Å—Ç–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–π, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∏—Å–∫–æ–º—ã–µ:
1. –î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –õ–ù–ú –æ—Å—Ç–∞–≤–∏—Ç—å —Ä–æ–≤–Ω–æ –æ–¥–Ω—É —Å–∏—Å—Ç–µ–º—É —Å —Å–∞–º—ã–º –±–æ–ª—å—à–∏–º –Ω–∞–±–æ—Ä–æ–º –∏–∑–Ω–∞—á–∞–ª—å–Ω—ã—Ö –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤.
   (–ü–æ—Å–∫–æ–ª—å–∫—É –µ—Å—Ç—å –Ω–∞–∏–±–æ–ª—å—à–∞—è –ø–æ –≤–∫–ª—é—á–µ–Ω–∏—é —Å–∏—Å—Ç–µ–º–∞, —Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤–∑—è—Ç—å –Ω–∞–∏–±–æ–ª—å—à—É—é –ø–æ —Ä–∞–∑–º–µ—Ä—É –∏ –Ω–µ –∑–∞–Ω–∏–º–∞—Ç—å—Å—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ–º —Å–∏—Å—Ç–µ–º.)
2. –î–ª—è –∫–∞–∂–¥–æ–π —Å–∏—Å—Ç–µ–º—ã –∑–∞–º–µ–Ω–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –õ–ù–ú –Ω–∞ –∫–∞–∫–æ–π-–Ω–∏–±—É–¥—å –±–∞–∑–∏—Å —è–¥—Ä–∞ —ç—Ç–æ–≥–æ –õ–ù–ú
   –∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ —è–¥—Ä–æ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º –ø–æ–ª–∏—Ç–æ–ø–æ–º.

–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ —É –≤—Å–µ—Ö —Å–∏—Å—Ç–µ–º –≤–∑—è—Ç—å —Ä–∞–∑–º–µ—Ä—ã –∏ –≤—ã–¥–µ–ª–∏—Ç—å –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —á–∏—Å–ª–∞ (–ø–æ –æ–¥–Ω–æ–º—É —Ä–∞–∑—É).

–ó–∞–≤–µ–¥—ë–º –¥–ª—è —ç—Ç–æ–≥–æ –≤—Å–µ–≥–æ —Ñ—É–Ω–∫—Ü–∏—é:
```kotlin title="filterEquationSystems.kt"
fun <
    Covector,
> filterEquationSystems(
    equationCases: KoneList<KoneList<EquationCase<Covector>>>
): KoneList<Covector> {
    TODO()
}
```

–î–ª—è –ø–µ—Ä–≤–æ–≥–æ –ø—É–Ω–∫—Ç–∞ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–ø–∏—Å–∫–∏ —Å–∏—Å—Ç–µ–º
–∏ –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Å–∏—Å—Ç–µ–º –≤ –æ–¥–Ω—É –º–∞–ø—É
(–∫–æ—Ç–æ—Ä–∞—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–∞–∂–¥–æ–º—É –õ–ù–ú –Ω–∞–∏–±–æ–ª—å—à—É—é —Å–∏—Å—Ç–µ–º—É):
```kotlin title="filterEquationSystems.kt"
context(
    covectorEquality: Equality<Covector>,
    covectorHashing: Hashing<Covector>,
)
fun <
    Covector,
> filterEquationSystems(
    equationCases: KoneList<KoneList<EquationCase<Covector>>>
): KoneList<Covector> {
    val equationToCases = equationCases.flatten().associateBy(
        keyEquality = KoneList.equality(covectorEquality),
        keyHashing = KoneList.hashing(covectorHashing),
        keySelector = { it.basis },
        valueTransform = { it.initialCovectors },
        resolve = { _, currentValue, newValue -> if (currentValue.size > newValue.size) currentValue else newValue }
    )

    TODO()
}
```

–¢–µ–ø–µ—Ä—å –º—ã –∑–∞–º–µ–Ω—è–µ–º –±–∞–∑–∏—Å –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω–∞ –±–∞–∑–∏—Å –≤–µ–∫—Ç–æ—Ä–æ–≤-—Ä–µ—à–µ–Ω–∏–π.
```kotlin title="filterEquationSystems.kt"
context(
    covectorEquality: Equality<Covector>,
    covectorHashing: Hashing<Covector>,
)
fun <
    Covector,
> filterEquationSystems(
    equationCases: KoneList<KoneList<EquationCase<Covector>>>
): KoneList<Covector> {
    val equationToCases = equationCases.flatten().associateBy(
        keyEquality = KoneList.equality(covectorEquality),
        keyHashing = KoneList.hashing(covectorHashing),
        keySelector = { it.basis },
        valueTransform = { it.initialCovectors },
        resolve = { _, currentValue, newValue -> if (currentValue.size > newValue.size) currentValue else newValue }
    )

    data class SolutionCase(
        val initialCovectors: KoneList<Covector>,
        val solutions: KoneList<Vector>,
    )

    val solutionCases = equationToCases.nodesView.map { (basis, initialCovectors) ->
        SolutionCase(
            initialCovectors = initialCovectors,
            solutions = basis.reducedRowEchelonFormKernel(
                dimension = dimension,
                vectorBasis = vectorBasis,
                covectorBasisDecomposition = covectorBasisDecomposition,
            ),
        )
    }

    TODO()
}
```

–î–∞–ª–µ–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–æ—Å—Ç–æ–∏—Ç –∏–∑ –¥–≤—É—Ö —à–∞–≥–æ–≤:
1. –°–ø—Ä–æ–µ—Ü–∏—Ä–æ–≤–∞—Ç—å –±–∞–∑–∏—Å –Ω–∞ –≥–∏–ø–µ—Ä–ø–ª–æ—Å–∫–æ—Å—Ç—å $\sum_{i=1}^n x_i = 1$.
2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–µ—Ä–µ—Å–µ–∫–∞–µ–º–æ—Å—Ç—å –ø—Ä–æ–µ–∫—Ü–∏–∏ —Å –ø–æ–ª–∏—Ç–æ–ø–æ–º.

–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –ø–µ—Ä–≤—ã–π –ø—É–Ω–∫—Ç.
–î–ª—è –≤—Å—è–∫–æ–≥–æ –±–∞–∑–∏—Å–Ω–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ $v$, –µ—Å–ª–∏ $\sum_{i=1}^n v_i \neq 0$, —Ç–æ $\frac{v}{\sum_{i=1}^n v_i}$ –±—É–¥–µ—Ç –ø—Ä–æ–µ–∫—Ü–∏–µ–π $v$.
–ï—Å–ª–∏ –∂–µ $\sum_{i=1}^n v_i = 0$, –Ω–æ –µ—Å—Ç—å $u$, —á—Ç–æ $\sum_{i=1}^n u_i \neq 0$, —Ç–æ –≤–º–µ—Å—Ç–æ $v$ –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å $v + u$.
–ï—Å–ª–∏ –∂–µ —Ç–∞–∫–æ–≥–æ $u$ –Ω–µ—Ç, —Ç–æ –ø—Ä–æ–µ–∫—Ü–∏—è –ø—É—Å—Ç–∞ –∏ –ø–æ–ª—É—á–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É –æ—Ç–≤–µ—Ç "–Ω–µ –∏–º–µ–µ—Ç —Ä–µ—à–µ–Ω–∏–π –≤ –ø–æ–ª–∏—Ç–æ–ø–µ".
```kotlin title="filterEquationSystems.kt"
context(
    covectorEquality: Equality<Covector>,
    covectorHashing: Hashing<Covector>,
)
fun <
    Covector,
> filterEquationSystems(
    equationCases: KoneList<KoneList<EquationCase<Covector>>>
): KoneList<Covector> {
    val equationToCases = equationCases.flatten().associateBy(
        keyEquality = KoneList.equality(covectorEquality),
        keyHashing = KoneList.hashing(covectorHashing),
        keySelector = { it.basis },
        valueTransform = { it.initialCovectors },
        resolve = { _, currentValue, newValue -> if (currentValue.size > newValue.size) currentValue else newValue }
    )

    data class SolutionCase(
        val initialCovectors: KoneList<Covector>,
        val solutions: KoneList<Vector>,
    )

    val solutionCases = equationToCases.nodesView.map { (basis, initialCovectors) ->
        SolutionCase(
            initialCovectors = initialCovectors,
            solutions = basis.reducedRowEchelonFormKernel(
                dimension = dimension,
                vectorBasis = vectorBasis,
                covectorBasisDecomposition = covectorBasisDecomposition,
            ),
        )
    }

    fun VectorSpaceBasisDecomposition.Result<Number, UInt>.sum(): Number =
        (0u ..< dimension).toKoneList().sumOf<_, Number> { this[it] }

    val filteredSolutionCases = solutionCases.mapNotNull { solutionCase ->
        val solutionBasisDecompositions = solutionCase.solutions.map { vectorBasis.decompose(it) }
        val nonZeroSumSolutionIndex = solutionBasisDecompositions.firstIndexThat { _, decomposition ->
            decomposition.sum().isNotZero()
        }
        if (nonZeroSumSolutionIndex == solutionCase.solutions.size) return@mapNotNull null
        val nonZeroSumSolution = solutionCase.solutions[nonZeroSumSolutionIndex]
        val nonZeroSumSolutionSum = solutionBasisDecompositions[nonZeroSumSolutionIndex].sum()
        SolutionCase(
            initialCovectors = solutionCase.initialCovectors,
            solutions = solutionCase.solutions.mapIndexed { index, vector ->
                val sum = solutionBasisDecompositions[index].sum()
                if (sum.isNotZero()) vector / sum else (nonZeroSumSolution + vector) / nonZeroSumSolutionSum
            }
        )
    }

    TODO()
}
```

–í—Ç–æ—Ä–æ–π –∂–µ –ø—É–Ω–∫—Ç –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ `checkIntersectionOfAreaAndSolutions`.
```kotlin title="filterEquationSystems.kt"
context(
    covectorEquality: Equality<Covector>,
    covectorHashing: Hashing<Covector>,
)
fun <
    Covector,
> filterEquationSystems(
    equationCases: KoneList<KoneList<EquationCase<Covector>>>
): KoneList<Covector> {
    val equationToCases = equationCases.flatten().associateBy(
        keyEquality = KoneList.equality(covectorEquality),
        keyHashing = KoneList.hashing(covectorHashing),
        keySelector = { it.basis },
        valueTransform = { it.initialCovectors },
        resolve = { _, currentValue, newValue -> if (currentValue.size > newValue.size) currentValue else newValue }
    )

    data class SolutionCase(
        val initialCovectors: KoneList<Covector>,
        val solutions: KoneList<Vector>,
    )

    val solutionCases = equationToCases.nodesView.map { (basis, initialCovectors) ->
        SolutionCase(
            initialCovectors = initialCovectors,
            solutions = basis.reducedRowEchelonFormKernel(
                dimension = dimension,
                vectorBasis = vectorBasis,
                covectorBasisDecomposition = covectorBasisDecomposition,
            ),
        )
    }

    fun VectorSpaceBasisDecomposition.Result<Number, UInt>.sum(): Number =
        (0u ..< dimension).toKoneList().sumOf<_, Number> { this[it] }

    val filteredSolutionCases = solutionCases.mapNotNull { solutionCase ->
        val solutionBasisDecompositions = solutionCase.solutions.map { vectorBasis.decompose(it) }
        val nonZeroSumSolutionIndex = solutionBasisDecompositions.firstIndexThat { _, decomposition ->
            decomposition.sum().isNotZero()
        }
        if (nonZeroSumSolutionIndex == solutionCase.solutions.size) return@mapNotNull null
        val nonZeroSumSolution = solutionCase.solutions[nonZeroSumSolutionIndex]
        val nonZeroSumSolutionSum = solutionBasisDecompositions[nonZeroSumSolutionIndex].sum()
        SolutionCase(
            initialCovectors = solutionCase.initialCovectors,
            solutions = solutionCase.solutions.mapIndexed { index, vector ->
                val sum = solutionBasisDecompositions[index].sum()
                if (sum.isNotZero()) vector / sum else (nonZeroSumSolution + vector) / nonZeroSumSolutionSum
            }
        )
    }

    val areaToCheckIntersectionWith = areaToCheckIntersectionWith(dimension = dimension, basis = vectorBasis)

    val checkedSolutionCases = filteredSolutionCases.filter { solutionCase ->
        checkIntersectionOfAreaAndSolutions(
            area = areaToCheckIntersectionWith,
            solutions = solutionCase.solutions.map { PointWrapper(it) },
        )
    }

    return checkedSolutionCases.map { it.initialCovectors }
}
```

## –§–∏–Ω–∞–ª –ø–µ—Ä–≤–æ–π –≤–µ—Ä—Å–∏–∏: —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫—É—Å–æ—á–∫–∏ –≤–æ–µ–¥–∏–Ω–æ

–¢–µ–ø–µ—Ä—å –æ—Å—Ç–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å –∫–æ–¥ –≤–æ–µ–¥–∏–Ω–æ.
–£ –Ω–∞—Å –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –≤—Å–µ—Ö —Å–∏—Å—Ç–µ–º-–ø—Ä–µ—Ç–µ–Ω–¥–µ–Ω—Ç–æ–≤ –∏ —Ñ—É–Ω–∫—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —ç—Ç–∏—Ö —Å–∏—Å—Ç–µ–º.
–û—Å—Ç–∞—ë—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –∏—Ö –≤ –æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –ø–æ—Å—á–∏—Ç–∞—Ç—å –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã.
```kotlin title="possibleResultNumbers.kt"
context(
    _: Field<Number>,
    _: Hashing<Number>,
    _: Order<Number>,
    _: EuclideanSpaceOverField<Number, Vector, PointWrapper<Vector>>,
    _: Hashing<Vector>,
    _: VectorSpace<*, Covector>,
    _: Hashing<Covector>,
    _: BasisExtender<Covector>,
)
fun <Number, Vector, Covector> possibleResultNumbers(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasis: VectorSpaceBasis.Finite<Number, Covector>,
): KoneList<UInt> {
    val equationCases = computePossibleEquationSystems(
        dimension = dimension,
        covectorBasis = covectorBasis,
    )

    val checkedSolutionCases = equationCases.filterEquationSystems(
        dimension = dimension,
        vectorBasis = vectorBasis,
        covectorBasisDecomposition = covectorBasis,
    )

    return checkedSolutionCases
        .mapTo(
            KoneMutableSet.of(
                elementEquality = UInt.context,
                elementHashing = UInt.context,
                elementOrder = UInt.context,
            )
        ) { it.size }
        .sorted()
}
```

–ê –≤ –≥–ª–∞–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –ø—Ä–æ—Å—Ç–æ –ø–æ–¥—Å—Ç–∞–≤–∏–º –≤ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç–∏–ø—ã —á–∏—Å–µ–ª, –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤,
–∞ —Ç–∞–∫–∂–µ –∏–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤—Å–µ—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤.
```kotlin title="main.kt"
typealias Number = BigLongRational
typealias Vector = MDList1<Number>

fun main() {
    print("n = ")
    val dimension = readln().toUInt()

    val field: Field<Number> = Number.context
    val numberHashing: Hashing<Number> = Number.context
    val numberOrder: Order<Number> = Number.context
    val euclideanSpace: EuclideanSpaceOverField<Number, Vector, PointWrapper<Vector>> =
        EuclideanSpaceOverField.mdList1(field, dimension)
    val vectorHashing: Hashing<Vector> = MDList1.hashing(Number.context)
    val vectorBasis: VectorSpaceBasis.Finite<Number, Vector> =
        object : VectorSpaceBasis.Finite<Number, Vector> {
            override val size: UInt get() = dimension

            override fun decompose(vector: Vector): VectorSpaceBasisDecomposition.Result<Number, UInt> =
                VectorSpaceBasisDecomposition.Result { index -> vector[index] }

            override fun get(index: UInt): Vector =
                MDList1(dimension) { if (it == index) field.one else field.zero }
        }
    val basisExtender: BasisExtender<Vector> =
        GaussReducedRowEchelonFormBasisExtender(
            field = field,
            vectorSpace = euclideanSpace,
            basisDecomposition = vectorBasis
        )

    context(
        field,
        numberHashing,
        numberOrder,
        euclideanSpace,
        vectorHashing,
        basisExtender
    ) {
        println(possibleResultNumbers(dimension, vectorBasis, vectorBasis))
    }
}
```

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã

–î–∞–ª–µ–µ –æ–ø–∏—Å–∞–Ω—ã, –∫–∞–∫–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–¥–∞—ë—Ç –ø–µ—Ä–≤–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –∫–∞–∫ –¥–æ–ª–≥–æ –æ–Ω–∞ –∏—Ö —Å—á–∏—Ç–∞–µ—Ç.

| $n$ |          –†–µ–∑—É–ª—å—Ç–∞—Ç           |   –í—Ä–µ–º—è    |
|:---:|:----------------------------:|:----------:|
|  3  |             [0]              | 300-400 ms |
|  4  |         [0, 1, 2, 3]         |  ~600 ms   |
|  5  |       [0, 1, 2, 3, 4]        |   6-7 s    |
|  6  | [0, 1, 2, 3, 4, 5, 6, 7, 10] |   ~12 m    |
|  7  |             ???              |   >10 h    |

## ‚ú® –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–µ—Ä–≤–∞—è: —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º —É—Ä–∞–≤–Ω–µ–Ω–∏–π –≤–æ –≤—Ä–µ–º—è –∏—Ö –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è

–ü–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ —ç—Ç–æ —Å–æ–≤—Å–µ–º –Ω–µ –∏–¥–µ–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.
–ê –∏–º–µ–Ω–Ω–æ –≤ —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –∑–∞–º–µ—Ç–∏–º, —á—Ç–æ —É –Ω–∞—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –Ω–µ–∏–º–æ–≤–µ—Ä–Ω–æ –º–Ω–æ–≥–æ –∫–æ–ø–∏–π –∫–∞–∂–¥–æ–π –≤–æ–∑–º–æ–∂–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã.
–ò –µ—â—ë —É –Ω–∞—Å –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è —Å–∏—Å—Ç–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã —Å—Ä–∞–∑—É –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞—Ç—å.

–ù–∞—á–Ω—ë–º —Å –ø–µ—Ä–≤–æ–≥–æ.
–ü–æ–Ω—è—Ç–Ω–æ, —á—Ç–æ –µ—Å–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä–∞—è —Å–∏—Å—Ç–µ–º–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–π —Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–º –õ–ù–ú,
—Ç–æ –ª—é–±–∞—è –¥—Ä—É–≥–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å —Ç–µ–º –∂–µ –õ–ù–ú —Ç–æ–∂–µ –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.
–ù–∞ –¥–µ–ª–µ —É –Ω–∞—Å –ø–µ—Ä–µ–±–∏—Ä–∞—é—Ç—Å—è $2^{n-1}$ –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ –≤—Å–µ $2^{2^{n-1}} - 1$ —Å–∏—Å—Ç–µ–º, –∫–æ—Ç–æ—Ä—ã–µ –æ–Ω–∏ –ø–æ—Ä–æ–∂–¥–∞—é—Ç, –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.
–≠—Ç–æ —Å–∏–ª—å–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –Ω–∞—à—É –ø—Ä–æ–≥—Ä–∞–º–º—É –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
(–µ—Å–ª–∏ –Ω–µ –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –µ—ë –≤–æ–≤—Å–µ –∑–∞–∫–æ–Ω—á–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º `OutOfMemoryError`).
–ß—Ç–æ –∂–µ –¥–µ–ª–∞—Ç—å?

–ù–∞ –¥–µ–ª–µ –æ—Ç–≤–µ—Ç –Ω–∞ —ç—Ç–æ—Ç –ø—É–Ω–∫—Ç –ø—Ä–æ—Å—Ç–æ–π.
–ú—ã –∑–Ω–∞–µ–º, —á—Ç–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –õ–ù–ú –µ—Å—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –ø–æ –≤–∫–ª—é—á–µ–Ω–∏—é —Å–∏—Å—Ç–µ–º–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–π, –ø–æ—Ä–æ–∂–¥–∞—é—â–∞—è —ç—Ç–æ –õ–ù–ú.
–ò –Ω–∞–º –Ω—É–∂–µ–Ω –∏–º–µ–Ω–Ω–æ —Ä–∞–∑–º–µ—Ä —Ç–∞–∫–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã!
–ó–Ω–∞—á–∏—Ç, –≤–º–µ—Å—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–æ–≥–æ –∂–µ –õ–ù–ú —Å –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π –¥–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Å—Ç–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å —Å–∏—Å—Ç–µ–º—É –∏–º–µ—é—â–µ–≥–æ—Å—è –õ–ù–ú.

–†–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ñ—É–Ω–∫—Ü–∏—é `computePossibleEquationSystems`, –∫–æ—Ç–æ—Ä–∞—è –∑–∞ —ç—Ç–æ –æ—Ç–≤–µ—á–∞–µ—Ç.
–ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–µ–º –µ—ë –Ω—ã–Ω–µ—à–Ω–∏–π –∫–æ–¥.
```kotlin title="computePossibleEquationSystems.kt"
data class EquationCase<Covector>(
    val initialCovectors: KoneList<Covector>,
    val basis: KoneList<Covector>,
)

context(_: VectorSpace<*, Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneArrayGrowableList<EquationCase<Covector>>()
    }

    equationCases[0u].add(
        EquationCase(
            initialCovectors = KoneList.empty(),
            basis = KoneList.empty(),
        )
    )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in dimension - 1u downTo 0u) for (case in equationCases[dim].toKoneList()) {
            val newBasis = case.basis.extend(vector)
            if (newBasis.size == dimension) continue
            equationCases[newBasis.size].add(
                EquationCase(
                    initialCovectors = KoneList.build(case.initialCovectors.size + 1u) {
                        addAllFrom(case.initialCovectors)
                        add(vector)
                    },
                    basis = newBasis,
                )
            )
        }
    }

    return equationCases
}
```

–í–æ-–ø–µ—Ä–≤—ã—Ö, –ø–æ–≤—Ç–æ—Ä–∏–º—Å—è, —á—Ç–æ —Ç–µ–ø–µ—Ä—å –º—ã —Ö–æ—Ç–∏–º,
—á—Ç–æ–±—ã `equationCases` (–≤ –∫–∞–∂–¥–æ–º —Å–≤–æ—ë–º —ç–ª–µ–º–µ–Ω—Ç–µ) —Ö—Ä–∞–Ω–∏–ª –ø–æ –∫–∫–∞–∂–¥–æ–º—É –õ–ù–ú —Ä–æ–≤–Ω–æ –æ–¥–Ω—É —Å–∏—Å—Ç–µ–º—É, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ä–∞—Å—à–∏—Ä—è—Ç—å—Å—è.
–ó–Ω–∞—á–∏—Ç, —Ç–µ–ø–µ—Ä—å `equationCases` –∏–º–µ–µ—Ç —Ç–∏–ø `KoneList<KoneMutableMap<KoneList<Covector>, KoneMutableSet<Covector>>>`.
–ó–¥–µ—Å—å `KoneMutableSet<Covector>` —Ö—Ä–∞–Ω–∏—Ç –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–∞ —Å–∏—Å—Ç–µ–º—ã,
`KoneList<Covector>` –æ–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–≤–µ–∫—Ç–æ—Ä–∞ –õ–ù–ú,
`KoneMutableMap<KoneList<Covector>, KoneMutableSet<Covector>>` –æ–ø–∏—Å—ã–≤–∞–µ—Ç –≤—Å–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è "–õ–ù–ú ‚Üí —Å–∏—Å—Ç–µ–º–∞ —É—Ä–∞–≤–Ω–µ–Ω–∏–π"
–¥–ª—è –¥–∞–Ω–Ω–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ –õ–ù–ú,
–∞ –≤—Å—ë `equationCases` —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ —Ö—Ä–∞–Ω–∏—Ç –≤—Å–µ —Ç–∞–∫–∏–µ –Ω–∞–±–æ—Ä—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π –¥–ª—è –∫–∞–∂–¥–æ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ –æ—Ç $0$ –¥–æ $n-1$.
–ò –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Å—Ç–æ–∏—Ç —Ç–∞–∫—É—é –∂–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–º –≤–∏–¥–µ, —Ç.–µ. —Ç–∏–ø–∞ `KoneList<KoneMap<KoneList<Covector>, KoneSet<Covector>>>`.
```kotlin title="computePossibleEquationSystems.kt"
context(_: VectorSpace<*, Covector>, covectorHashing: Hashing<Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneList<EquationCase<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneMutableMap.of<KoneList<Covector>, KoneMutableSet<Covector>>(
            keyEquality = KoneList.equality(covectorSpace),
            keyHashing = KoneList.hashing(covectorHashing),
        )
    }

    equationCases[0u][KoneList.empty()] =
        KoneMutableSet.of(
            elementEquality = covectorSpace,
            elementHashing = covectorHashing,
        )

    TODO()

    return equationCases
}
```

–•–æ—Ä–æ—à–æ, —Ç–µ–ø–µ—Ä—å –±—É–¥–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –≤–µ–∫—Ç–æ—Ä–∞, —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ `dim` –∏ —Å–∏—Å—Ç–µ–º—ã —É—Ä–∞–≤–Ω–µ–Ω–∏–π —Å –õ–ù–ú —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏ `dim`
–∏ —Ä–∞—Å—à–∏—Ä—è—Ç—å –õ–ù–ú –¥–∞–Ω–Ω—ã–º –≤–µ–∫—Ç–æ—Ä–æ–º.
```kotlin title="computePossibleEquationSystems.kt"
context(covectorSpace: VectorSpace<*, Covector>, covectorHashing: Hashing<Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneMap<KoneList<Covector>, KoneSet<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneMutableMap.of<KoneList<Covector>, KoneMutableSet<Covector>>(
            keyEquality = KoneList.equality(covectorSpace),
            keyHashing = KoneList.hashing(covectorHashing),
        )
    }

    equationCases[0u][KoneList.empty()] =
        KoneMutableSet.of(
            elementEquality = covectorSpace,
            elementHashing = covectorHashing,
        )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in 0u ..< dimension) for ((basis, initialCovectors) in equationCases[dim]) {
            if (vector in initialCovectors) continue
            val newBasis = basis.extend(vector)

            TODO()
        }
    }

    return equationCases
}
```

–î–∞–ª—å—à–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏—è –≤ –≤–µ—Ä—Å–∏–∏ 1.
–ï—Å–ª–∏ –õ–ù–ú –Ω–µ —É–≤–µ–ª–∏—á–∏–ª—Å—è, —Ç–æ –ø—Ä–æ—Å—Ç–æ —Å—Ç–æ–∏—Ç –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º—ã–π –≤–µ–∫—Ç–æ—Ä –≤ —Å–∏—Å—Ç–µ–º—É –∏ –∏–¥—Ç–∏ –¥–∞–ª—å—à–µ.
–ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∞—Å—å –õ–ù–ú –±–æ–ª—å—à–µ–π —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–∏, —Ç–æ –Ω—É–∂–Ω–æ –ø–æ–∏—Å–∫–∞—Ç—å –≤ —Å–ª–µ–¥—É—é—â–µ–π –º–∞–ø–µ, –µ—Å—Ç—å –ª–∏ —Ç–∞–º —Ç–∞–∫–∞—è –õ–ù–ú.
–ï—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å, —Ç–æ –Ω–∞–¥–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ–º—É—é –µ–π —Å–∏—Å—Ç–µ–º—É –≤–µ–∫—Ç–æ—Ä–æ–º –∏ —Å–∏—Å—Ç–µ–º–æ–π, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –ø–µ—Ä–µ–±–∏—Ä–∞–µ–º.
–ò–Ω–∞—á–µ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ç–∏ –∂–µ –≤–µ–∫—Ç–æ—Ä –∏ —Å–∏—Å—Ç–µ–º—É –≤–º–µ—Å—Ç–µ —Å –Ω–æ–≤–æ–π –õ–ù–ú –≤ –º–∞–ø—É.
```kotlin title="computePossibleEquationSystems.kt"
context(covectorSpace: VectorSpace<*, Covector>, covectorHashing: Hashing<Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
): KoneList<KoneMap<KoneList<Covector>, KoneSet<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneMutableMap.of<KoneList<Covector>, KoneMutableSet<Covector>>(
            keyEquality = KoneList.equality(covectorSpace),
            keyHashing = KoneList.hashing(covectorHashing),
        )
    }

    equationCases[0u][KoneList.empty()] =
        KoneMutableSet.of(
            elementEquality = covectorSpace,
            elementHashing = covectorHashing,
        )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in 0u ..< dimension) for ((basis, initialCovectors) in equationCases[dim]) {
            if (vector in initialCovectors) continue
            val newBasis = basis.extend(vector)
            when (newBasis.size) {
                basis.size -> {
                    initialCovectors.add(vector)
                }
                basis.size + 1u -> {
                    if (dim != dimension - 1u)
                        equationCases[dim + 1u].setOrChange(
                            newBasis,
                            {
                                KoneMutableSet.of(
                                    elementEquality = covectorSpace,
                                    elementHashing = covectorHashing,
                                ).apply {
                                    addAllFrom(initialCovectors)
                                    add(vector)
                                }
                            },
                            { oldInitialCovectors ->
                                oldInitialCovectors.add(vector)
                                oldInitialCovectors
                            }
                        )
                }
                else -> error("Unexpected size of new basis")
            }
        }
    }

    return equationCases
}
```

–¢–µ–ø–µ—Ä—å –≤—Å–ø–æ–º–Ω–∏–º –≤—Ç–æ—Ä–æ–π –ø—É–Ω–∫—Ç: –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –õ–ù–ú —Å–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤–ª—è–µ–º, –∞ –ø–æ—Ç–æ–º –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤—ã–≤–∞–µ–º.
–ù–æ –º–æ–∂–Ω–æ –ª–∏ –∏—Ö –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å —Å—Ä–∞–∑—É?
–û—Ç–≤–µ—Ç, –∫ —Å—á–∞—Å—Ç—å—é, &mdash; –¥–∞.
–í–µ–¥—å –µ—Å–ª–∏ –∫–∞–∫–æ–µ-—Ç–æ –õ–ù–ú –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç, —Ç.–µ. –µ–≥–æ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —Ä–µ—à–µ–Ω–∏–π –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è —Å –Ω—É–∂–Ω–æ–π –æ–±–ª–∞—Å—Ç—å—é,
—Ç–æ –∏ –µ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è —Ç–æ–∂–µ –±—É–¥—É—Ç –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç—å.
–ó–Ω–∞—á–∏—Ç, –ø—Ä–∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–∏ –õ–ù–ú –º–æ–∂–Ω–æ (–∏ –Ω—É–∂–Ω–æ) –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –æ–Ω–∞ –≤–æ–æ–±—â–µ –Ω–∞–º –ø–æ–¥—Ö–æ–¥–∏—Ç,
–∏ –µ—Å–ª–∏ –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç, —Ç–æ –ø—Ä–æ—Å—Ç–æ –ø–æ–π—Ç–∏ –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –¥–∞–ª—å—à–µ.
–î–ª—è —ç—Ç–æ–≥–æ –¥–∞–≤–∞–π—Ç–µ –Ω–µ –≤—Å—Ç–∞–≤–ª—è—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º –∫–∞–∫ –µ—Å—Ç—å, –∞ –≤—ã—Ä–∞–∑–∏–º –µ–≥–æ –≤ –≤–∏–¥–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ç–∏–ø–∞ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞:
```kotlin title="computePossibleEquationSystems.kt"
fun interface BasisValidator<Covector> {
    fun validate(basis: KoneList<Covector>): Boolean
}

context(covectorSpace: VectorSpace<*, Covector>, covectorHashing: Hashing<Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
    basisValidator: BasisValidator<Covector>,
): KoneList<KoneMap<KoneList<Covector>, KoneSet<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneMutableMap.of<KoneList<Covector>, KoneMutableSet<Covector>>(
            keyEquality = KoneList.equality(covectorSpace),
            keyHashing = KoneList.hashing(covectorHashing),
        )
    }

    equationCases[0u][KoneList.empty()] =
        KoneMutableSet.of(
            elementEquality = covectorSpace,
            elementHashing = covectorHashing,
        )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in 0u ..< dimension) for ((basis, initialCovectors) in equationCases[dim]) {
            if (vector in initialCovectors) continue
            val newBasis = basis.extend(vector)
            when (newBasis.size) {
                basis.size -> {
                    initialCovectors.add(vector)
                }
                basis.size + 1u -> {
                    if (dim != dimension - 1u && basisValidator.validate(newBasis))
                        equationCases[dim + 1u].setOrChange(
                            newBasis,
                            {
                                KoneMutableSet.of(
                                    elementEquality = covectorSpace,
                                    elementHashing = covectorHashing,
                                ).apply {
                                    addAllFrom(initialCovectors)
                                    add(vector)
                                }
                            },
                            { oldInitialCovectors ->
                                oldInitialCovectors.add(vector)
                                oldInitialCovectors
                            }
                        )
                }
                else -> error("Unexpected size of new basis")
            }
        }
    }

    return equationCases
}
```

–¢–µ–ø–µ—Ä—å –∏–∑–º–µ–Ω–∏–≤ —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é, —É–¥–∞–ª–∏–º `filterEquationSystems` –∏ –∏—Å–ø—Ä–∞–≤–∏–º `possibleResultNumbers`.
```kotlin title="possibleResultNumbers.kt"
context(
    _: Field<Number>,
    _: Hashing<Number>,
    _: Order<Number>,
    _: EuclideanSpaceOverField<Number, Vector, PointWrapper<Vector>>,
    _: Hashing<Vector>,
    _: VectorSpace<*, Covector>,
    _: Hashing<Covector>,
    _: BasisExtender<Covector>,
)
fun <Number, Vector, Covector> possibleResultNumbers(
    dimension: UInt,
    vectorBasis: VectorSpaceBasis.Finite<Number, Vector>,
    covectorBasis: VectorSpaceBasis.Finite<Number, Covector>,
): KoneList<UInt> {
    val areaToCheckIntersectionWith = areaToCheckIntersectionWith(dimension = dimension, basis = vectorBasis)

    fun VectorSpaceBasisDecomposition.Result<Number, UInt>.sum(): Number =
        (0u ..< dimension).toKoneList().sumOf<_, Number> { this[it] }

    val equationCases = computePossibleEquationSystems(
        dimension = dimension,
        covectorBasis = covectorBasis,
        basisValidator = BasisValidator { basis ->
            val solutions = basis.reducedRowEchelonFormKernel(dimension, vectorBasis, covectorBasis)
            val solutionBasisDecompositions = solutions.map { vectorBasis.decompose(it) }
            val nonZeroSumSolutionIndex = solutionBasisDecompositions.firstIndexThat { _, decomposition ->
                (0u ..< dimension).toKoneList().sumOf<_, Number> { decomposition[it] }.isNotZero()
            }
            if (nonZeroSumSolutionIndex == solutions.size) return@BasisValidator false
            val nonZeroSumSolution = solutions[nonZeroSumSolutionIndex]
            val nonZeroSumSolutionSum = solutionBasisDecompositions[nonZeroSumSolutionIndex].sum()

            checkIntersectionOfAreaAndSolutions(
                area = areaToCheckIntersectionWith,
                solutions = solutions.mapIndexed { index, vector ->
                    val sum = solutionBasisDecompositions[index].sum()
                    PointWrapper(if (sum.isNotZero()) vector / sum else (nonZeroSumSolution + vector) / nonZeroSumSolutionSum)
                },
            )
        }
    )

    val result =
        KoneMutableSet.of(
            elementEquality = UInt.context,
            elementHashing = UInt.context,
            elementOrder = UInt.context,
        )

    for (dimensionEquations in equationCases) for (equation in dimensionEquations.valuesView) result.add(equation.size)

    return result.sorted()
}
```

–§—É–Ω–∫—Ü–∏—è `main` –Ω–µ –ø–æ–º–µ–Ω—è–ª–∞—Å—å.

### –†–µ–∑—É–ª—å—Ç–∞—Ç—ã

–î–∞–ª–µ–µ –æ–ø–∏—Å–∞–Ω—ã, –∫–∞–∫–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–¥–∞—ë—Ç –≤—Ç–æ—Ä–∞—è –≤–µ—Ä—Å–∏—è –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏ –∫–∞–∫ –¥–æ–ª–≥–æ –æ–Ω–∞ –∏—Ö —Å—á–∏—Ç–∞–µ—Ç.

| $n$ |          –†–µ–∑—É–ª—å—Ç–∞—Ç           |   –í—Ä–µ–º—è    |
|:---:|:----------------------------:|:----------:|
|  3  |             [0]              | 300-400 ms |
|  4  |         [0, 1, 2, 3]         |  ~500 ms   |
|  5  |       [0, 1, 2, 3, 4]        |   4-5 s    |
|  6  | [0, 1, 2, 3, 4, 5, 6, 7, 10] |    ~5 m    |
|  7  |             ???              |   >10 h    |

## ‚ú® –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –≤—Ç–æ—Ä–∞—è: –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–ª—É—á–∞–µ–≤ –õ–ù–ú, –æ—Ç–ª–∏—á–Ω—ã—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç

–í —ç—Ç–æ–º —Ä–∞–∑–¥–µ–ª–µ –∑–∞–º–µ—Ç–∏–º, —á—Ç–æ –ø–æ–ª—É—á–∞—é—â–∏–µ—Å—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –ø–æ –≤–∫–ª—é—á–µ–Ω–∏—é —Å–∏—Å—Ç–µ–º—ã –º–æ–∂–Ω–æ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç—å –¥—Ä—É–≥ –≤ –¥—Ä—É–≥–∞ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∞–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
–°–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, –º–æ–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –Ω–µ —Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ —Ç–∞–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã, –∞ –æ–±—ä–µ–¥–∏–Ω—è—Ç—å —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.
–¢.–µ., –ø–æ–ª—É—á–∞—è –Ω–æ–≤–æ–µ –õ–ù–ú, –Ω–∞–º –Ω—É–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –Ω–∞–π—Ç–∏ –æ–¥–Ω–æ –∏–∑ —Å—Ç–∞—Ä—ã—Ö –õ–ù–ú,
–∫–æ—Ç–æ—Ä–æ–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –∏ —Å–Ω–æ–≤–∞ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ–º –∫ –ø—Ä–∏–≤–µ–¥—ë–Ω–Ω–æ–π —Å—Ç—É–ø–µ–Ω—á–∞—Ç–æ–π —Ñ–æ—Ä–º–µ.
–ü—Ä–∏ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏–∏ —Å—Ç–∞—Ä–æ–≥–æ, –¥–æ–±–∞–≤–∏—Ç—å –≤ –µ–≥–æ —Å–∏—Å—Ç–µ–º—É –∫–æ–≤–µ–∫—Ç–æ—Ä–æ–≤ –Ω–æ–≤—ã–π –∫–æ–≤–µ–∫—Ç–æ—Ä —Å —Ç–∞–∫–∏–º –∂–µ —Å–ø–æ—Å–æ–±–æ–º –ø–µ—Ä–µ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏.
–ò–Ω–∞—á–µ, –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –õ–ù–ú —Å –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π —É—Ä–∞–≤–Ω–µ–Ω–∏–π.

–†–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ñ—É–Ω–∫—Ü–∏—é `computePossibleEquationSystems`, –∫–æ—Ç–æ—Ä–∞—è –∑–∞ —ç—Ç–æ –æ—Ç–≤–µ—á–∞–µ—Ç.
–ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –ø—Ä–æ–¥—É–±–ª–∏—Ä—É–µ–º –µ—ë –Ω—ã–Ω–µ—à–Ω–∏–π –∫–æ–¥.
```kotlin title="computePossibleEquationSystems.kt"
context(covectorSpace: VectorSpace<*, Covector>, covectorHashing: Hashing<Covector>, _: BasisExtender<Covector>)
fun <
    Covector,
> computePossibleEquationSystems(
    dimension: UInt,
    covectorBasis: VectorSpaceBasis.Finite<*, Covector>,
    basisValidator: BasisValidator<Covector>,
): KoneList<KoneMap<KoneList<Covector>, KoneSet<Covector>>> {
    val equationCases = KoneList(dimension) {
        KoneMutableMap.of<KoneList<Covector>, KoneMutableSet<Covector>>(
            keyEquality = KoneList.equality(covectorSpace),
            keyHashing = KoneList.hashing(covectorHashing),
        )
    }

    equationCases[0u][KoneList.empty()] =
        KoneMutableSet.of(
            elementEquality = covectorSpace,
            elementHashing = covectorHashing,
        )

    for (coefficients in KoneList.of(1, -1).cartesianPower(dimension - 1u)) {
        if (coefficients.all { it == 1 }) continue
        val vector = coefficients.foldIndexed(covectorBasis[0u]) { index, accumulator, element ->
            accumulator + element * covectorBasis[index + 1u]
        }

        for (dim in 0u ..< dimension) for ((basis, initialCovectors) in equationCases[dim]) {
            if (vector in initialCovectors) continue
            val newBasis = basis.extend(vector)
            when (newBasis.size) {
                basis.size -> {
                    initialCovectors.add(vector)
                }
                basis.size + 1u -> {
                    if (dim != dimension - 1u && basisValidator.validate(newBasis))
                        equationCases[dim + 1u].setOrChange(
                            newBasis,
                            {
                                KoneMutableSet.of(
                                    elementEquality = covectorSpace,
                                    elementHashing = covectorHashing,
                                ).apply {
                                    addAllFrom(initialCovectors)
                                    add(vector)
                                }
                            },
                            { oldInitialCovectors ->
                                oldInitialCovectors.add(vector)
                                oldInitialCovectors
                            }
                        )
                }
                else -> error("Unexpected size of new basis")
            }
        }
    }

    return equationCases
}
```

[//]: # (–ù–∞–º –Ω–∞–¥–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å –≤–µ—Ç–∫—É `if &#40;dim != dimension - 1u && basisValidator.validate&#40;newBasis&#41;&#41;` –≤ –Ω–µ–π –ø–µ—Ä–µ–±–æ—Ä–æ–º –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫.)
